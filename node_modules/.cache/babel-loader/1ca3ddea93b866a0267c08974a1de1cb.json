{"ast":null,"code":"var _jsxFileName = \"/Users/harryholcomb/Desktop/React Native/GitHub/Sharetribe/ftw-product/src/containers/CheckoutPage/CheckoutPage.js\";\nimport React, { Component } from 'react';\nimport { bool, func, instanceOf, object, oneOfType, shape, string } from 'prop-types';\nimport { compose } from 'redux';\nimport { connect } from 'react-redux';\nimport { withRouter } from 'react-router-dom';\nimport classNames from 'classnames'; // Import configs and util modules\n\nimport config from '../../config';\nimport { FormattedMessage, injectIntl, intlShape } from '../../util/reactIntl';\nimport routeConfiguration from '../../routing/routeConfiguration';\nimport { pathByRouteName, findRouteByRouteName } from '../../util/routes';\nimport { propTypes, LINE_ITEM_NIGHT, LINE_ITEM_DAY, DATE_TYPE_DATE } from '../../util/types';\nimport { ensureListing, ensureCurrentUser, ensureUser, ensureTransaction, ensureBooking, ensureStripeCustomer, ensurePaymentMethodCard } from '../../util/data';\nimport { timeOfDayFromLocalToTimeZone, minutesBetween } from '../../util/dates';\nimport { createSlug } from '../../util/urlHelpers';\nimport { isTransactionInitiateAmountTooLowError, isTransactionInitiateListingNotFoundError, isTransactionInitiateMissingStripeAccountError, isTransactionInitiateBookingTimeNotAvailableError, isTransactionInitiateListingInsufficientStockError, isTransactionChargeDisabledError, isTransactionZeroPaymentError, isTransitionQuantityInfoMissingError, transactionInitiateOrderStripeErrors } from '../../util/errors';\nimport { formatMoney } from '../../util/currency';\nimport { TRANSITION_ENQUIRE, txIsPaymentPending, txIsPaymentExpired, txHasPassedPaymentPending } from '../../util/transaction'; // Import global thunk functions\n\nimport { isScrollingDisabled } from '../../ducks/UI.duck';\nimport { confirmCardPayment, retrievePaymentIntent } from '../../ducks/stripe.duck';\nimport { savePaymentMethod } from '../../ducks/paymentMethods.duck'; // Import shared components\n\nimport { AvatarMedium, AspectRatioWrapper, OrderBreakdown, Logo, NamedLink, NamedRedirect, Page, ResponsiveImage } from '../../components'; // Import modules from this directory\n\nimport { initiateOrder, setInitialValues, speculateTransaction, stripeCustomer, confirmPayment, sendMessage } from './CheckoutPage.duck';\nimport StripePaymentForm from './StripePaymentForm/StripePaymentForm';\nimport { storeData, storedData, clearData } from './CheckoutPageSessionHelpers';\nimport css from './CheckoutPage.module.css';\nconst STORAGE_KEY = 'CheckoutPage'; // Stripe PaymentIntent statuses, where user actions are already completed\n// https://stripe.com/docs/payments/payment-intents/status\n\nconst STRIPE_PI_USER_ACTIONS_DONE_STATUSES = ['processing', 'requires_capture', 'succeeded']; // Payment charge options\n\nconst ONETIME_PAYMENT = 'ONETIME_PAYMENT';\nconst PAY_AND_SAVE_FOR_LATER_USE = 'PAY_AND_SAVE_FOR_LATER_USE';\nconst USE_SAVED_CARD = 'USE_SAVED_CARD';\n\nconst paymentFlow = (selectedPaymentMethod, saveAfterOnetimePayment) => {\n  // Payment mode could be 'replaceCard', but without explicit saveAfterOnetimePayment flag,\n  // we'll handle it as one-time payment\n  return selectedPaymentMethod === 'defaultCard' ? USE_SAVED_CARD : saveAfterOnetimePayment ? PAY_AND_SAVE_FOR_LATER_USE : ONETIME_PAYMENT;\n};\n\nconst initializeOrderPage = (initialValues, routes, dispatch) => {\n  const OrderPage = findRouteByRouteName('OrderDetailsPage', routes); // Transaction is already created, but if the initial message\n  // sending failed, we tell it to the OrderDetailsPage.\n\n  dispatch(OrderPage.setInitialValues(initialValues));\n};\n\nconst checkIsPaymentExpired = existingTransaction => {\n  return txIsPaymentExpired(existingTransaction) ? true : txIsPaymentPending(existingTransaction) ? minutesBetween(existingTransaction.attributes.lastTransitionedAt, new Date()) >= 15 : false;\n};\n\nconst getFormattedTotalPrice = (transaction, intl) => {\n  const totalPrice = transaction.attributes.payinTotal;\n  return formatMoney(intl, totalPrice);\n}; // Convert the picked date to moment that will represent the same time of day in UTC time zone.\n\n\nconst bookingDatesMaybe = bookingDates => {\n  const apiTimeZone = 'Etc/UTC';\n  return bookingDates ? {\n    bookingDates: {\n      bookingStart: timeOfDayFromLocalToTimeZone(bookingDates.bookingStart, apiTimeZone),\n      bookingEnd: timeOfDayFromLocalToTimeZone(bookingDates.bookingEnd, apiTimeZone)\n    }\n  } : {};\n}; // Collect error message checks to a single function.\n\n\nconst getErrorMessages = (listingNotFound, initiateOrderError, speculateTransactionError, listingLink) => {\n  let listingNotFoundErrorMessage = null;\n  let initiateOrderErrorMessage = null;\n  let speculateErrorMessage = null;\n  const isAmountTooLowError = isTransactionInitiateAmountTooLowError(initiateOrderError);\n  const isChargeDisabledError = isTransactionChargeDisabledError(initiateOrderError);\n  const stripeErrors = transactionInitiateOrderStripeErrors(initiateOrderError); // We want to show one error at a time for the real transition\n\n  if (listingNotFound) {\n    listingNotFoundErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.listingNotFoundError\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 146,\n        columnNumber: 35\n      }\n    });\n  } else if (isAmountTooLowError) {\n    initiateOrderErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.initiateOrderAmountTooLow\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 148,\n        columnNumber: 33\n      }\n    });\n  } else if (isTransactionInitiateBookingTimeNotAvailableError(initiateOrderError)) {\n    // If bookings are used, there could be error related to those\n    initiateOrderErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.bookingTimeNotAvailableMessage\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 152,\n        columnNumber: 7\n      }\n    });\n  } else if (isTransitionQuantityInfoMissingError(initiateOrderError)) {\n    initiateOrderErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.correctQuantityInformationMissing\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 156,\n        columnNumber: 7\n      }\n    });\n  } else if (isTransactionInitiateListingInsufficientStockError(initiateOrderError)) {\n    // If stock management is used, there could be error related to that\n    initiateOrderErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.notEnoughStockMessage\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 160,\n        columnNumber: 33\n      }\n    });\n  } else if (isChargeDisabledError) {\n    initiateOrderErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.chargeDisabledMessage\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 162,\n        columnNumber: 33\n      }\n    });\n  } else if (stripeErrors && stripeErrors.length > 0) {\n    // NOTE: Error messages from Stripes are not part of translations.\n    // By default they are in English.\n    const stripeErrorsAsString = stripeErrors.join(', ');\n    initiateOrderErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.initiateOrderStripeError\",\n      values: {\n        stripeErrors: stripeErrorsAsString\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 168,\n        columnNumber: 7\n      }\n    });\n  } else if (initiateOrderError) {\n    // Generic initiate order error\n    initiateOrderErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.initiateOrderError\",\n      values: {\n        listingLink\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 176,\n        columnNumber: 7\n      }\n    });\n  } // We want to show one error at a time for speculateTransition\n\n\n  if (isTransactionInitiateMissingStripeAccountError(speculateTransactionError)) {\n    speculateErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.providerStripeAccountMissingError\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 183,\n        columnNumber: 7\n      }\n    });\n  } else if (isTransactionInitiateBookingTimeNotAvailableError(speculateTransactionError)) {\n    speculateErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.bookingTimeNotAvailableMessage\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 186,\n        columnNumber: 29\n      }\n    });\n  } else if (isTransactionInitiateListingInsufficientStockError(speculateTransactionError)) {\n    speculateErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.notEnoughStockMessage\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 188,\n        columnNumber: 29\n      }\n    });\n  } else if (isTransactionZeroPaymentError(speculateTransactionError)) {\n    speculateErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.initiateOrderAmountTooLow\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 29\n      }\n    });\n  } else if (isTransitionQuantityInfoMissingError(speculateTransactionError)) {\n    speculateErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.correctQuantityInformationMissing\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 193,\n        columnNumber: 7\n      }\n    });\n  } else if (speculateTransactionError) {\n    speculateErrorMessage = /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.speculateFailedMessage\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 196,\n        columnNumber: 29\n      }\n    });\n  } // Add paragraph-container for the error message, if it exists\n\n\n  const listingNotFoundErrorMessageParagraph = listingNotFoundErrorMessage ? /*#__PURE__*/React.createElement(\"p\", {\n    className: css.notFoundError,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 201,\n      columnNumber: 5\n    }\n  }, listingNotFoundErrorMessage) : null;\n  const initiateOrderErrorMessageParagraph = initiateOrderErrorMessage ? /*#__PURE__*/React.createElement(\"p\", {\n    className: css.orderError,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 204,\n      columnNumber: 5\n    }\n  }, initiateOrderErrorMessage) : null;\n  const speculateErrorMessageParagraph = speculateErrorMessage ? /*#__PURE__*/React.createElement(\"p\", {\n    className: css.orderError,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 207,\n      columnNumber: 5\n    }\n  }, speculateErrorMessage) : null;\n  const speculateTransactionErrorMessageParagraph = speculateTransactionError ? /*#__PURE__*/React.createElement(\"p\", {\n    className: css.speculateError,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 210,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(FormattedMessage, {\n    id: \"CheckoutPage.speculateTransactionError\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 211,\n      columnNumber: 7\n    }\n  })) : null;\n  return {\n    listingNotFoundErrorMessage: listingNotFoundErrorMessageParagraph,\n    initiateOrderErrorMessage: initiateOrderErrorMessageParagraph,\n    speculateErrorMessage: speculateErrorMessageParagraph,\n    speculateTransactionErrorMessage: speculateTransactionErrorMessageParagraph\n  };\n};\n\nexport class CheckoutPageComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      pageData: {},\n      dataLoaded: false,\n      submitting: false\n    };\n    this.stripe = null;\n    this.onStripeInitialized = this.onStripeInitialized.bind(this);\n    this.loadInitialData = this.loadInitialData.bind(this);\n    this.handlePaymentIntent = this.handlePaymentIntent.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  componentDidMount() {\n    if (window) {\n      this.loadInitialData();\n    }\n  }\n  /**\n   * Load initial data for the page\n   *\n   * Since the data for the checkout is not passed in the URL (there\n   * might be lots of options in the future), we must pass in the data\n   * some other way. Currently the ListingPage sets the initial data\n   * for the CheckoutPage's Redux store.\n   *\n   * For some cases (e.g. a refresh in the CheckoutPage), the Redux\n   * store is empty. To handle that case, we store the received data\n   * to window.sessionStorage and read it from there if no props from\n   * the store exist.\n   *\n   * This function also sets of fetching the speculative transaction\n   * based on this initial data.\n   */\n\n\n  loadInitialData() {\n    const {\n      orderData,\n      listing,\n      transaction,\n      fetchSpeculatedTransaction,\n      fetchStripeCustomer,\n      history\n    } = this.props; // Fetch currentUser with stripeCustomer entity\n    // Note: since there's need for data loading in \"componentWillMount\" function,\n    //       this is added here instead of loadData static function.\n\n    fetchStripeCustomer(); // Browser's back navigation should not rewrite data in session store.\n    // Action is 'POP' on both history.back() and page refresh cases.\n    // Action is 'PUSH' when user has directed through a link\n    // Action is 'REPLACE' when user has directed through login/signup process\n\n    const hasNavigatedThroughLink = history.action === 'PUSH' || history.action === 'REPLACE';\n    const hasDataInProps = !!(orderData && listing && hasNavigatedThroughLink);\n\n    if (hasDataInProps) {\n      // Store data only if data is passed through props and user has navigated through a link.\n      storeData(orderData, listing, transaction, STORAGE_KEY);\n    } // NOTE: stored data can be empty if user has already successfully completed transaction.\n\n\n    const pageData = hasDataInProps ? {\n      orderData,\n      listing,\n      transaction\n    } : storedData(STORAGE_KEY);\n    const tx = pageData ? pageData.transaction : null; // If transaction has passed payment-pending state, speculated tx is not needed.\n\n    const shouldFetchSpeculatedTransaction = pageData && pageData.listing && pageData.listing.id && pageData.orderData && !txHasPassedPaymentPending(tx);\n\n    if (shouldFetchSpeculatedTransaction) {\n      var _pageData$orderData, _pageData$orderData2;\n\n      const listingId = pageData.listing.id;\n      const transactionId = tx ? tx.id : null; // Fetch speculated transaction for showing price in order breakdown\n      // NOTE: if unit type is line-item/units, quantity needs to be added.\n      // The way to pass it to checkout page is through pageData.orderData\n\n      const quantity = (_pageData$orderData = pageData.orderData) === null || _pageData$orderData === void 0 ? void 0 : _pageData$orderData.quantity;\n      const quantityMaybe = quantity ? {\n        quantity\n      } : {};\n      const deliveryMethod = (_pageData$orderData2 = pageData.orderData) === null || _pageData$orderData2 === void 0 ? void 0 : _pageData$orderData2.deliveryMethod;\n      fetchSpeculatedTransaction({\n        listingId,\n        deliveryMethod,\n        ...quantityMaybe,\n        ...bookingDatesMaybe(pageData.orderData.bookingDates)\n      }, transactionId);\n    }\n\n    this.setState({\n      pageData: pageData || {},\n      dataLoaded: true\n    });\n  }\n\n  handlePaymentIntent(handlePaymentParams) {\n    var _pageData$orderData3, _pageData$orderData4;\n\n    const {\n      currentUser,\n      stripeCustomerFetched,\n      onInitiateOrder,\n      onConfirmCardPayment,\n      onConfirmPayment,\n      onSendMessage,\n      onSavePaymentMethod\n    } = this.props;\n    const {\n      pageData,\n      speculatedTransaction,\n      message,\n      paymentIntent,\n      selectedPaymentMethod,\n      saveAfterOnetimePayment,\n      shippingDetails\n    } = handlePaymentParams;\n    const storedTx = ensureTransaction(pageData.transaction);\n    const ensuredCurrentUser = ensureCurrentUser(currentUser);\n    const ensuredStripeCustomer = ensureStripeCustomer(ensuredCurrentUser.stripeCustomer);\n    const ensuredDefaultPaymentMethod = ensurePaymentMethodCard(ensuredStripeCustomer.defaultPaymentMethod);\n    let createdPaymentIntent = null;\n    const hasDefaultPaymentMethod = !!(stripeCustomerFetched && ensuredStripeCustomer.attributes.stripeCustomerId && ensuredDefaultPaymentMethod.id);\n    const stripePaymentMethodId = hasDefaultPaymentMethod ? ensuredDefaultPaymentMethod.attributes.stripePaymentMethodId : null;\n    const selectedPaymentFlow = paymentFlow(selectedPaymentMethod, saveAfterOnetimePayment); // Step 1: initiate order by requesting payment from Marketplace API\n\n    const fnRequestPayment = fnParams => {\n      // fnParams should be { listingId, deliveryMethod, quantity?, bookingDates?, paymentMethod?/setupPaymentMethodForSaving? }\n      const hasPaymentIntents = storedTx.attributes.protectedData && storedTx.attributes.protectedData.stripePaymentIntents; // If paymentIntent exists, order has been initiated previously.\n\n      return hasPaymentIntents ? Promise.resolve(storedTx) : onInitiateOrder(fnParams, storedTx.id);\n    }; // Step 2: pay using Stripe SDK\n\n\n    const fnConfirmCardPayment = fnParams => {\n      // fnParams should be returned transaction entity\n      const order = ensureTransaction(fnParams);\n\n      if (order.id) {\n        // Store order.\n        const {\n          orderData,\n          listing\n        } = pageData;\n        storeData(orderData, listing, order, STORAGE_KEY);\n        this.setState({\n          pageData: { ...pageData,\n            transaction: order\n          }\n        });\n      }\n\n      const hasPaymentIntents = order.attributes.protectedData && order.attributes.protectedData.stripePaymentIntents;\n\n      if (!hasPaymentIntents) {\n        throw new Error(`Missing StripePaymentIntents key in transaction's protectedData. Check that your transaction process is configured to use payment intents.`);\n      }\n\n      const {\n        stripePaymentIntentClientSecret\n      } = hasPaymentIntents ? order.attributes.protectedData.stripePaymentIntents.default : null;\n      const {\n        stripe,\n        card,\n        billingDetails,\n        paymentIntent\n      } = handlePaymentParams;\n      const stripeElementMaybe = selectedPaymentFlow !== USE_SAVED_CARD ? {\n        card\n      } : {}; // Note: For basic USE_SAVED_CARD scenario, we have set it already on API side, when PaymentIntent was created.\n      // However, the payment_method is save here for USE_SAVED_CARD flow if customer first attempted onetime payment\n\n      const paymentParams = selectedPaymentFlow !== USE_SAVED_CARD ? {\n        payment_method: {\n          billing_details: billingDetails,\n          card: card\n        }\n      } : {\n        payment_method: stripePaymentMethodId\n      };\n      const params = {\n        stripePaymentIntentClientSecret,\n        orderId: order.id,\n        stripe,\n        ...stripeElementMaybe,\n        paymentParams\n      }; // If paymentIntent status is not waiting user action,\n      // confirmCardPayment has been called previously.\n\n      const hasPaymentIntentUserActionsDone = paymentIntent && STRIPE_PI_USER_ACTIONS_DONE_STATUSES.includes(paymentIntent.status);\n      return hasPaymentIntentUserActionsDone ? Promise.resolve({\n        transactionId: order.id,\n        paymentIntent\n      }) : onConfirmCardPayment(params);\n    }; // Step 3: complete order by confirming payment to Marketplace API\n    // Parameter should contain { paymentIntent, transactionId } returned in step 2\n\n\n    const fnConfirmPayment = fnParams => {\n      createdPaymentIntent = fnParams.paymentIntent;\n      return onConfirmPayment(fnParams);\n    }; // Step 4: send initial message\n\n\n    const fnSendMessage = fnParams => {\n      return onSendMessage({ ...fnParams,\n        message\n      });\n    }; // Step 5: optionally save card as defaultPaymentMethod\n\n\n    const fnSavePaymentMethod = fnParams => {\n      const pi = createdPaymentIntent || paymentIntent;\n\n      if (selectedPaymentFlow === PAY_AND_SAVE_FOR_LATER_USE) {\n        return onSavePaymentMethod(ensuredStripeCustomer, pi.payment_method).then(response => {\n          if (response.errors) {\n            return { ...fnParams,\n              paymentMethodSaved: false\n            };\n          }\n\n          return { ...fnParams,\n            paymentMethodSaved: true\n          };\n        }).catch(e => {\n          // Real error cases are catched already in paymentMethods page.\n          return { ...fnParams,\n            paymentMethodSaved: false\n          };\n        });\n      } else {\n        return Promise.resolve({ ...fnParams,\n          paymentMethodSaved: true\n        });\n      }\n    }; // Here we create promise calls in sequence\n    // This is pretty much the same as:\n    // fnRequestPayment({...initialParams})\n    //   .then(result => fnConfirmCardPayment({...result}))\n    //   .then(result => fnConfirmPayment({...result}))\n\n\n    const applyAsync = (acc, val) => acc.then(val);\n\n    const composeAsync = (...funcs) => x => funcs.reduce(applyAsync, Promise.resolve(x));\n\n    const handlePaymentIntentCreation = composeAsync(fnRequestPayment, fnConfirmCardPayment, fnConfirmPayment, fnSendMessage, fnSavePaymentMethod); // Create order aka transaction\n    // NOTE: if unit type is line-item/units, quantity needs to be added.\n    // The way to pass it to checkout page is through pageData.orderData\n\n    const tx = speculatedTransaction ? speculatedTransaction : storedTx;\n    const deliveryMethod = (_pageData$orderData3 = pageData.orderData) === null || _pageData$orderData3 === void 0 ? void 0 : _pageData$orderData3.deliveryMethod;\n    const quantity = (_pageData$orderData4 = pageData.orderData) === null || _pageData$orderData4 === void 0 ? void 0 : _pageData$orderData4.quantity;\n    const quantityMaybe = quantity ? {\n      quantity\n    } : {};\n    const protectedDataMaybe = deliveryMethod && shippingDetails ? {\n      protectedData: {\n        deliveryMethod,\n        shippingDetails\n      }\n    } : deliveryMethod ? {\n      protectedData: {\n        deliveryMethod\n      }\n    } : {}; // Note: optionalPaymentParams contains Stripe paymentMethod,\n    // but that can also be passed on Step 2\n    // stripe.confirmCardPayment(stripe, { payment_method: stripePaymentMethodId })\n\n    const optionalPaymentParams = selectedPaymentFlow === USE_SAVED_CARD && hasDefaultPaymentMethod ? {\n      paymentMethod: stripePaymentMethodId\n    } : selectedPaymentFlow === PAY_AND_SAVE_FOR_LATER_USE ? {\n      setupPaymentMethodForSaving: true\n    } : {};\n    const orderParams = {\n      listingId: pageData.listing.id,\n      deliveryMethod,\n      ...quantityMaybe,\n      ...bookingDatesMaybe(pageData.orderData.bookingDates),\n      ...protectedDataMaybe,\n      ...optionalPaymentParams\n    };\n    return handlePaymentIntentCreation(orderParams);\n  }\n\n  handleSubmit(values) {\n    if (this.state.submitting) {\n      return;\n    }\n\n    this.setState({\n      submitting: true\n    });\n    const {\n      history,\n      speculatedTransaction,\n      currentUser,\n      paymentIntent,\n      dispatch\n    } = this.props;\n    const {\n      card,\n      message,\n      paymentMethod,\n      formValues\n    } = values;\n    const {\n      name,\n      addressLine1,\n      addressLine2,\n      postal,\n      city,\n      state,\n      country,\n      saveAfterOnetimePayment,\n      recipientName,\n      recipientPhoneNumber,\n      recipientAddressLine1,\n      recipientAddressLine2,\n      recipientPostal,\n      recipientCity,\n      recipientState,\n      recipientCountry\n    } = formValues; // Billing address is recommended.\n    // However, let's not assume that <StripePaymentAddress> data is among formValues.\n    // Read more about this from Stripe's docs\n    // https://stripe.com/docs/stripe-js/reference#stripe-handle-card-payment-no-element\n\n    const addressMaybe = addressLine1 && postal ? {\n      address: {\n        city: city,\n        country: country,\n        line1: addressLine1,\n        line2: addressLine2,\n        postal_code: postal,\n        state: state\n      }\n    } : {};\n    const billingDetails = {\n      name,\n      email: ensureCurrentUser(currentUser).attributes.email,\n      ...addressMaybe\n    };\n    const shippingDetailsMaybe = recipientName && recipientAddressLine1 && recipientPostal ? {\n      shippingDetails: {\n        name: recipientName,\n        phoneNumber: recipientPhoneNumber,\n        address: {\n          city: recipientCity,\n          country: recipientCountry,\n          line1: recipientAddressLine1,\n          line2: recipientAddressLine2,\n          postalCode: recipientPostal,\n          state: recipientState\n        }\n      }\n    } : {};\n    const requestPaymentParams = {\n      pageData: this.state.pageData,\n      speculatedTransaction,\n      stripe: this.stripe,\n      card,\n      billingDetails,\n      message,\n      paymentIntent,\n      selectedPaymentMethod: paymentMethod,\n      saveAfterOnetimePayment: Array.isArray(saveAfterOnetimePayment) && saveAfterOnetimePayment.length > 0,\n      ...shippingDetailsMaybe\n    };\n    this.handlePaymentIntent(requestPaymentParams).then(res => {\n      const {\n        orderId,\n        messageSuccess,\n        paymentMethodSaved\n      } = res;\n      this.setState({\n        submitting: false\n      });\n      const routes = routeConfiguration();\n      const initialMessageFailedToTransaction = messageSuccess ? null : orderId;\n      const orderDetailsPath = pathByRouteName('OrderDetailsPage', routes, {\n        id: orderId.uuid\n      });\n      const initialValues = {\n        initialMessageFailedToTransaction,\n        savePaymentMethodFailed: !paymentMethodSaved\n      };\n      initializeOrderPage(initialValues, routes, dispatch);\n      clearData(STORAGE_KEY);\n      history.push(orderDetailsPath);\n    }).catch(err => {\n      console.error(err);\n      this.setState({\n        submitting: false\n      });\n    });\n  }\n\n  onStripeInitialized(stripe) {\n    this.stripe = stripe;\n    const {\n      paymentIntent,\n      onRetrievePaymentIntent\n    } = this.props;\n    const tx = this.state.pageData ? this.state.pageData.transaction : null; // We need to get up to date PI, if payment is pending but it's not expired.\n\n    const shouldFetchPaymentIntent = this.stripe && !paymentIntent && tx && tx.id && txIsPaymentPending(tx) && !checkIsPaymentExpired(tx);\n\n    if (shouldFetchPaymentIntent) {\n      const {\n        stripePaymentIntentClientSecret\n      } = tx.attributes.protectedData && tx.attributes.protectedData.stripePaymentIntents ? tx.attributes.protectedData.stripePaymentIntents.default : {}; // Fetch up to date PaymentIntent from Stripe\n\n      onRetrievePaymentIntent({\n        stripe,\n        stripePaymentIntentClientSecret\n      });\n    }\n  }\n\n  render() {\n    var _tx$booking, _tx$attributes$lineIt, _firstImage$attribute, _currentListing$attri, _currentListing$attri2;\n\n    const {\n      scrollingDisabled,\n      speculateTransactionInProgress,\n      speculateTransactionError,\n      speculatedTransaction: speculatedTransactionMaybe,\n      initiateOrderError,\n      confirmPaymentError,\n      intl,\n      params,\n      currentUser,\n      confirmCardPaymentError,\n      paymentIntent,\n      retrievePaymentIntentError,\n      stripeCustomerFetched\n    } = this.props; // Since the listing data is already given from the ListingPage\n    // and stored to handle refreshes, it might not have the possible\n    // deleted or closed information in it. If the transaction\n    // initiate or the speculative initiate fail due to the listing\n    // being deleted or closec, we should dig the information from the\n    // errors and not the listing data.\n\n    const listingNotFound = isTransactionInitiateListingNotFoundError(speculateTransactionError) || isTransactionInitiateListingNotFoundError(initiateOrderError);\n    const isLoading = !this.state.dataLoaded || speculateTransactionInProgress;\n    const {\n      listing,\n      transaction,\n      orderData\n    } = this.state.pageData;\n    const existingTransaction = ensureTransaction(transaction);\n    const speculatedTransaction = ensureTransaction(speculatedTransactionMaybe, {}, null);\n    const currentListing = ensureListing(listing);\n    const currentAuthor = ensureUser(currentListing.author);\n    const listingTitle = currentListing.attributes.title;\n    const title = intl.formatMessage({\n      id: 'CheckoutPage.title'\n    }, {\n      listingTitle\n    });\n    const pageProps = {\n      title,\n      scrollingDisabled\n    };\n    const topbar = /*#__PURE__*/React.createElement(\"div\", {\n      className: css.topbar,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 687,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(NamedLink, {\n      className: css.home,\n      name: \"LandingPage\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 688,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(Logo, {\n      className: css.logoMobile,\n      title: intl.formatMessage({\n        id: 'CheckoutPage.goToLandingPage'\n      }),\n      format: \"mobile\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 689,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(Logo, {\n      className: css.logoDesktop,\n      alt: intl.formatMessage({\n        id: 'CheckoutPage.goToLandingPage'\n      }),\n      format: \"desktop\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 694,\n        columnNumber: 11\n      }\n    })));\n\n    if (isLoading) {\n      return /*#__PURE__*/React.createElement(Page, Object.assign({}, pageProps, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 704,\n          columnNumber: 14\n        }\n      }), topbar);\n    }\n\n    const isOwnListing = currentUser && currentUser.id && currentAuthor && currentAuthor.id && currentAuthor.id.uuid === currentUser.id.uuid;\n    const hasRequiredData = !!(currentListing.id && currentAuthor.id);\n    const canShowPage = hasRequiredData && !isOwnListing;\n    const shouldRedirect = !isLoading && !canShowPage; // Redirect back to ListingPage if data is missing.\n    // Redirection must happen before any data format error is thrown (e.g. wrong currency)\n\n    if (shouldRedirect) {\n      // eslint-disable-next-line no-console\n      console.error('Missing or invalid data for checkout, redirecting back to listing page.', {\n        transaction: speculatedTransaction,\n        listing\n      });\n      return /*#__PURE__*/React.createElement(NamedRedirect, {\n        name: \"ListingPage\",\n        params: params,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 726,\n          columnNumber: 14\n        }\n      });\n    } // Show breakdown only when (speculated?) transaction is loaded\n    // (i.e. have an id and lineItems)\n\n\n    const tx = existingTransaction.booking ? existingTransaction : speculatedTransaction;\n    const txBookingMaybe = ((_tx$booking = tx.booking) === null || _tx$booking === void 0 ? void 0 : _tx$booking.id) ? {\n      booking: ensureBooking(tx.booking),\n      dateType: DATE_TYPE_DATE\n    } : {};\n    const breakdown = tx.id && ((_tx$attributes$lineIt = tx.attributes.lineItems) === null || _tx$attributes$lineIt === void 0 ? void 0 : _tx$attributes$lineIt.length) > 0 ? /*#__PURE__*/React.createElement(OrderBreakdown, Object.assign({\n      className: css.orderBreakdown,\n      userRole: \"customer\",\n      unitType: config.lineItemUnitType,\n      transaction: tx\n    }, txBookingMaybe, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 737,\n        columnNumber: 9\n      }\n    })) : null;\n    const isPaymentExpired = checkIsPaymentExpired(existingTransaction);\n    const hasDefaultPaymentMethod = !!(stripeCustomerFetched && ensureStripeCustomer(currentUser.stripeCustomer).attributes.stripeCustomerId && ensurePaymentMethodCard(currentUser.stripeCustomer.defaultPaymentMethod).id); // Allow showing page when currentUser is still being downloaded,\n    // but show payment form only when user info is loaded.\n\n    const showPaymentForm = !!(currentUser && hasRequiredData && !listingNotFound && !initiateOrderError && !speculateTransactionError && !retrievePaymentIntentError && !isPaymentExpired);\n    const firstImage = currentListing.images && currentListing.images.length > 0 ? currentListing.images[0] : null;\n    const {\n      aspectWidth = 1,\n      aspectHeight = 1,\n      variantPrefix = 'listing-card'\n    } = config.listing;\n    const variants = firstImage ? Object.keys(firstImage === null || firstImage === void 0 ? void 0 : (_firstImage$attribute = firstImage.attributes) === null || _firstImage$attribute === void 0 ? void 0 : _firstImage$attribute.variants).filter(k => k.startsWith(variantPrefix)) : [];\n    const listingLink = /*#__PURE__*/React.createElement(NamedLink, {\n      name: \"ListingPage\",\n      params: {\n        id: currentListing.id.uuid,\n        slug: createSlug(listingTitle)\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 774,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.errorlistingLinkText\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 778,\n        columnNumber: 9\n      }\n    }));\n    const {\n      listingNotFoundErrorMessage,\n      initiateOrderErrorMessage,\n      speculateErrorMessage,\n      speculateTransactionErrorMessage\n    } = getErrorMessages(listingNotFound, initiateOrderError, speculateTransactionError, listingLink);\n    const unitType = config.lineItemUnitType;\n    const isNightly = unitType === LINE_ITEM_NIGHT;\n    const isDaily = unitType === LINE_ITEM_DAY;\n    const unitTranslationKey = isNightly ? 'CheckoutPage.perNight' : isDaily ? 'CheckoutPage.perDay' : 'CheckoutPage.perUnit';\n    const price = currentListing.attributes.price;\n    const formattedPrice = formatMoney(intl, price);\n    const detailsSubTitle = `${formattedPrice} ${intl.formatMessage({\n      id: unitTranslationKey\n    })}`;\n    const showInitialMessageInput = !(existingTransaction && existingTransaction.attributes.lastTransition === TRANSITION_ENQUIRE); // Get first and last name of the current user and use it in the StripePaymentForm to autofill the name field\n\n    const userName = currentUser && currentUser.attributes ? `${currentUser.attributes.profile.firstName} ${currentUser.attributes.profile.lastName}` : null; // If paymentIntent status is not waiting user action,\n    // confirmCardPayment has been called previously.\n\n    const hasPaymentIntentUserActionsDone = paymentIntent && STRIPE_PI_USER_ACTIONS_DONE_STATUSES.includes(paymentIntent.status); // If your marketplace works mostly in one country you can use initial values to select country automatically\n    // e.g. {country: 'FI'}\n\n    const initalValuesForStripePayment = {\n      name: userName,\n      recipientName: userName\n    };\n    return /*#__PURE__*/React.createElement(Page, Object.assign({}, pageProps, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 829,\n        columnNumber: 7\n      }\n    }), topbar, /*#__PURE__*/React.createElement(\"div\", {\n      className: css.contentContainer,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 831,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(AspectRatioWrapper, {\n      width: aspectWidth,\n      height: aspectHeight,\n      className: css.aspectWrapper,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 832,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(ResponsiveImage, {\n      rootClassName: css.rootForImage,\n      alt: listingTitle,\n      image: firstImage,\n      variants: variants,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 837,\n        columnNumber: 13\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: classNames(css.avatarWrapper, css.avatarMobile),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 844,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(AvatarMedium, {\n      user: currentAuthor,\n      disableProfileLink: true,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 845,\n        columnNumber: 13\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: css.bookListingContainer,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 847,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: css.heading,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 848,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"h1\", {\n      className: css.title,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 849,\n        columnNumber: 15\n      }\n    }, title), /*#__PURE__*/React.createElement(\"div\", {\n      className: css.author,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 850,\n        columnNumber: 15\n      }\n    }, /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.providerInfo\",\n      values: {\n        name: currentAuthor.attributes.profile.displayName\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 851,\n        columnNumber: 17\n      }\n    }))), /*#__PURE__*/React.createElement(\"div\", {\n      className: css.priceBreakdownContainer,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 858,\n        columnNumber: 13\n      }\n    }, speculateTransactionErrorMessage, breakdown), /*#__PURE__*/React.createElement(\"section\", {\n      className: css.paymentContainer,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 863,\n        columnNumber: 13\n      }\n    }, initiateOrderErrorMessage, listingNotFoundErrorMessage, speculateErrorMessage, retrievePaymentIntentError ? /*#__PURE__*/React.createElement(\"p\", {\n      className: css.orderError,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 868,\n        columnNumber: 17\n      }\n    }, /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.retrievingStripePaymentIntentFailed\",\n      values: {\n        listingLink\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 869,\n        columnNumber: 19\n      }\n    })) : null, showPaymentForm ? /*#__PURE__*/React.createElement(StripePaymentForm, {\n      className: css.paymentForm,\n      onSubmit: this.handleSubmit,\n      inProgress: this.state.submitting,\n      formId: \"CheckoutPagePaymentForm\",\n      authorDisplayName: currentAuthor.attributes.profile.displayName,\n      showInitialMessageInput: showInitialMessageInput,\n      initialValues: initalValuesForStripePayment,\n      initiateOrderError: initiateOrderError,\n      confirmCardPaymentError: confirmCardPaymentError,\n      confirmPaymentError: confirmPaymentError,\n      hasHandledCardPayment: hasPaymentIntentUserActionsDone,\n      loadingData: !stripeCustomerFetched,\n      defaultPaymentMethod: hasDefaultPaymentMethod ? currentUser.stripeCustomer.defaultPaymentMethod : null,\n      paymentIntent: paymentIntent,\n      onStripeInitialized: this.onStripeInitialized,\n      askShippingDetails: (orderData === null || orderData === void 0 ? void 0 : orderData.deliveryMethod) === 'shipping',\n      pickupLocation: currentListing === null || currentListing === void 0 ? void 0 : (_currentListing$attri = currentListing.attributes) === null || _currentListing$attri === void 0 ? void 0 : (_currentListing$attri2 = _currentListing$attri.publicData) === null || _currentListing$attri2 === void 0 ? void 0 : _currentListing$attri2.location,\n      totalPrice: tx.id ? getFormattedTotalPrice(tx, intl) : null,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 876,\n        columnNumber: 17\n      }\n    }) : null, isPaymentExpired ? /*#__PURE__*/React.createElement(\"p\", {\n      className: css.orderError,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 900,\n        columnNumber: 17\n      }\n    }, /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.paymentExpiredMessage\",\n      values: {\n        listingLink\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 901,\n        columnNumber: 19\n      }\n    })) : null)), /*#__PURE__*/React.createElement(\"div\", {\n      className: css.detailsContainerDesktop,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 910,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(AspectRatioWrapper, {\n      width: aspectWidth,\n      height: aspectHeight,\n      className: css.detailsAspectWrapper,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 911,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(ResponsiveImage, {\n      rootClassName: css.rootForImage,\n      alt: listingTitle,\n      image: firstImage,\n      variants: variants,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 916,\n        columnNumber: 15\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: css.avatarWrapper,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 923,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(AvatarMedium, {\n      user: currentAuthor,\n      disableProfileLink: true,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 924,\n        columnNumber: 15\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      className: css.detailsHeadings,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 926,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"h2\", {\n      className: css.detailsTitle,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 927,\n        columnNumber: 15\n      }\n    }, listingTitle), /*#__PURE__*/React.createElement(\"p\", {\n      className: css.detailsSubtitle,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 928,\n        columnNumber: 15\n      }\n    }, detailsSubTitle)), speculateTransactionErrorMessage, /*#__PURE__*/React.createElement(\"h2\", {\n      className: css.orderBreakdownTitle,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 931,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"CheckoutPage.orderBreakdown\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 932,\n        columnNumber: 15\n      }\n    })), breakdown)));\n  }\n\n}\nCheckoutPageComponent.defaultProps = {\n  initiateOrderError: null,\n  confirmPaymentError: null,\n  listing: null,\n  orderData: {},\n  speculateTransactionError: null,\n  speculatedTransaction: null,\n  transaction: null,\n  currentUser: null,\n  paymentIntent: null\n};\nCheckoutPageComponent.propTypes = {\n  scrollingDisabled: bool.isRequired,\n  listing: propTypes.listing,\n  orderData: object,\n  fetchStripeCustomer: func.isRequired,\n  stripeCustomerFetched: bool.isRequired,\n  fetchSpeculatedTransaction: func.isRequired,\n  speculateTransactionInProgress: bool.isRequired,\n  speculateTransactionError: propTypes.error,\n  speculatedTransaction: propTypes.transaction,\n  transaction: propTypes.transaction,\n  currentUser: propTypes.currentUser,\n  params: shape({\n    id: string,\n    slug: string\n  }).isRequired,\n  onConfirmPayment: func.isRequired,\n  onInitiateOrder: func.isRequired,\n  onConfirmCardPayment: func.isRequired,\n  onRetrievePaymentIntent: func.isRequired,\n  onSavePaymentMethod: func.isRequired,\n  onSendMessage: func.isRequired,\n  initiateOrderError: propTypes.error,\n  confirmPaymentError: propTypes.error,\n  // confirmCardPaymentError comes from Stripe so that's why we can't expect it to be in a specific form\n  confirmCardPaymentError: oneOfType([propTypes.error, object]),\n  paymentIntent: object,\n  // from connect\n  dispatch: func.isRequired,\n  // from injectIntl\n  intl: intlShape.isRequired,\n  // from withRouter\n  history: shape({\n    push: func.isRequired\n  }).isRequired\n};\n\nconst mapStateToProps = state => {\n  const {\n    listing,\n    orderData,\n    stripeCustomerFetched,\n    speculateTransactionInProgress,\n    speculateTransactionError,\n    speculatedTransaction,\n    transaction,\n    initiateOrderError,\n    confirmPaymentError\n  } = state.CheckoutPage;\n  const {\n    currentUser\n  } = state.user;\n  const {\n    confirmCardPaymentError,\n    paymentIntent,\n    retrievePaymentIntentError\n  } = state.stripe;\n  return {\n    scrollingDisabled: isScrollingDisabled(state),\n    currentUser,\n    stripeCustomerFetched,\n    orderData,\n    speculateTransactionInProgress,\n    speculateTransactionError,\n    speculatedTransaction,\n    transaction,\n    listing,\n    initiateOrderError,\n    confirmCardPaymentError,\n    confirmPaymentError,\n    paymentIntent,\n    retrievePaymentIntentError\n  };\n};\n\nconst mapDispatchToProps = dispatch => ({\n  dispatch,\n  fetchSpeculatedTransaction: (params, transactionId) => dispatch(speculateTransaction(params, transactionId)),\n  fetchStripeCustomer: () => dispatch(stripeCustomer()),\n  onInitiateOrder: (params, transactionId) => dispatch(initiateOrder(params, transactionId)),\n  onRetrievePaymentIntent: params => dispatch(retrievePaymentIntent(params)),\n  onConfirmCardPayment: params => dispatch(confirmCardPayment(params)),\n  onConfirmPayment: params => dispatch(confirmPayment(params)),\n  onSendMessage: params => dispatch(sendMessage(params)),\n  onSavePaymentMethod: (stripeCustomer, stripePaymentMethodId) => dispatch(savePaymentMethod(stripeCustomer, stripePaymentMethodId))\n});\n\nconst CheckoutPage = compose(withRouter, connect(mapStateToProps, mapDispatchToProps), injectIntl)(CheckoutPageComponent);\n\nCheckoutPage.setInitialValues = (initialValues, saveToSessionStorage = false) => {\n  if (saveToSessionStorage) {\n    const {\n      listing,\n      orderData\n    } = initialValues;\n    storeData(orderData, listing, null, STORAGE_KEY);\n  }\n\n  return setInitialValues(initialValues);\n};\n\nCheckoutPage.displayName = 'CheckoutPage';\nexport default CheckoutPage;","map":{"version":3,"sources":["/Users/harryholcomb/Desktop/React Native/GitHub/Sharetribe/ftw-product/src/containers/CheckoutPage/CheckoutPage.js"],"names":["React","Component","bool","func","instanceOf","object","oneOfType","shape","string","compose","connect","withRouter","classNames","config","FormattedMessage","injectIntl","intlShape","routeConfiguration","pathByRouteName","findRouteByRouteName","propTypes","LINE_ITEM_NIGHT","LINE_ITEM_DAY","DATE_TYPE_DATE","ensureListing","ensureCurrentUser","ensureUser","ensureTransaction","ensureBooking","ensureStripeCustomer","ensurePaymentMethodCard","timeOfDayFromLocalToTimeZone","minutesBetween","createSlug","isTransactionInitiateAmountTooLowError","isTransactionInitiateListingNotFoundError","isTransactionInitiateMissingStripeAccountError","isTransactionInitiateBookingTimeNotAvailableError","isTransactionInitiateListingInsufficientStockError","isTransactionChargeDisabledError","isTransactionZeroPaymentError","isTransitionQuantityInfoMissingError","transactionInitiateOrderStripeErrors","formatMoney","TRANSITION_ENQUIRE","txIsPaymentPending","txIsPaymentExpired","txHasPassedPaymentPending","isScrollingDisabled","confirmCardPayment","retrievePaymentIntent","savePaymentMethod","AvatarMedium","AspectRatioWrapper","OrderBreakdown","Logo","NamedLink","NamedRedirect","Page","ResponsiveImage","initiateOrder","setInitialValues","speculateTransaction","stripeCustomer","confirmPayment","sendMessage","StripePaymentForm","storeData","storedData","clearData","css","STORAGE_KEY","STRIPE_PI_USER_ACTIONS_DONE_STATUSES","ONETIME_PAYMENT","PAY_AND_SAVE_FOR_LATER_USE","USE_SAVED_CARD","paymentFlow","selectedPaymentMethod","saveAfterOnetimePayment","initializeOrderPage","initialValues","routes","dispatch","OrderPage","checkIsPaymentExpired","existingTransaction","attributes","lastTransitionedAt","Date","getFormattedTotalPrice","transaction","intl","totalPrice","payinTotal","bookingDatesMaybe","bookingDates","apiTimeZone","bookingStart","bookingEnd","getErrorMessages","listingNotFound","initiateOrderError","speculateTransactionError","listingLink","listingNotFoundErrorMessage","initiateOrderErrorMessage","speculateErrorMessage","isAmountTooLowError","isChargeDisabledError","stripeErrors","length","stripeErrorsAsString","join","listingNotFoundErrorMessageParagraph","notFoundError","initiateOrderErrorMessageParagraph","orderError","speculateErrorMessageParagraph","speculateTransactionErrorMessageParagraph","speculateError","speculateTransactionErrorMessage","CheckoutPageComponent","constructor","props","state","pageData","dataLoaded","submitting","stripe","onStripeInitialized","bind","loadInitialData","handlePaymentIntent","handleSubmit","componentDidMount","window","orderData","listing","fetchSpeculatedTransaction","fetchStripeCustomer","history","hasNavigatedThroughLink","action","hasDataInProps","tx","shouldFetchSpeculatedTransaction","id","listingId","transactionId","quantity","quantityMaybe","deliveryMethod","setState","handlePaymentParams","currentUser","stripeCustomerFetched","onInitiateOrder","onConfirmCardPayment","onConfirmPayment","onSendMessage","onSavePaymentMethod","speculatedTransaction","message","paymentIntent","shippingDetails","storedTx","ensuredCurrentUser","ensuredStripeCustomer","ensuredDefaultPaymentMethod","defaultPaymentMethod","createdPaymentIntent","hasDefaultPaymentMethod","stripeCustomerId","stripePaymentMethodId","selectedPaymentFlow","fnRequestPayment","fnParams","hasPaymentIntents","protectedData","stripePaymentIntents","Promise","resolve","fnConfirmCardPayment","order","Error","stripePaymentIntentClientSecret","default","card","billingDetails","stripeElementMaybe","paymentParams","payment_method","billing_details","params","orderId","hasPaymentIntentUserActionsDone","includes","status","fnConfirmPayment","fnSendMessage","fnSavePaymentMethod","pi","then","response","errors","paymentMethodSaved","catch","e","applyAsync","acc","val","composeAsync","funcs","x","reduce","handlePaymentIntentCreation","protectedDataMaybe","optionalPaymentParams","paymentMethod","setupPaymentMethodForSaving","orderParams","values","formValues","name","addressLine1","addressLine2","postal","city","country","recipientName","recipientPhoneNumber","recipientAddressLine1","recipientAddressLine2","recipientPostal","recipientCity","recipientState","recipientCountry","addressMaybe","address","line1","line2","postal_code","email","shippingDetailsMaybe","phoneNumber","postalCode","requestPaymentParams","Array","isArray","res","messageSuccess","initialMessageFailedToTransaction","orderDetailsPath","uuid","savePaymentMethodFailed","push","err","console","error","onRetrievePaymentIntent","shouldFetchPaymentIntent","render","scrollingDisabled","speculateTransactionInProgress","speculatedTransactionMaybe","confirmPaymentError","confirmCardPaymentError","retrievePaymentIntentError","isLoading","currentListing","currentAuthor","author","listingTitle","title","formatMessage","pageProps","topbar","home","logoMobile","logoDesktop","isOwnListing","hasRequiredData","canShowPage","shouldRedirect","booking","txBookingMaybe","dateType","breakdown","lineItems","orderBreakdown","lineItemUnitType","isPaymentExpired","showPaymentForm","firstImage","images","aspectWidth","aspectHeight","variantPrefix","variants","Object","keys","filter","k","startsWith","slug","unitType","isNightly","isDaily","unitTranslationKey","price","formattedPrice","detailsSubTitle","showInitialMessageInput","lastTransition","userName","profile","firstName","lastName","initalValuesForStripePayment","contentContainer","aspectWrapper","rootForImage","avatarWrapper","avatarMobile","bookListingContainer","heading","displayName","priceBreakdownContainer","paymentContainer","paymentForm","publicData","location","detailsContainerDesktop","detailsAspectWrapper","detailsHeadings","detailsTitle","detailsSubtitle","orderBreakdownTitle","defaultProps","isRequired","mapStateToProps","CheckoutPage","user","mapDispatchToProps","saveToSessionStorage"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { bool, func, instanceOf, object, oneOfType, shape, string } from 'prop-types';\nimport { compose } from 'redux';\nimport { connect } from 'react-redux';\nimport { withRouter } from 'react-router-dom';\nimport classNames from 'classnames';\n\n// Import configs and util modules\nimport config from '../../config';\nimport { FormattedMessage, injectIntl, intlShape } from '../../util/reactIntl';\nimport routeConfiguration from '../../routing/routeConfiguration';\nimport { pathByRouteName, findRouteByRouteName } from '../../util/routes';\nimport { propTypes, LINE_ITEM_NIGHT, LINE_ITEM_DAY, DATE_TYPE_DATE } from '../../util/types';\nimport {\n  ensureListing,\n  ensureCurrentUser,\n  ensureUser,\n  ensureTransaction,\n  ensureBooking,\n  ensureStripeCustomer,\n  ensurePaymentMethodCard,\n} from '../../util/data';\nimport { timeOfDayFromLocalToTimeZone, minutesBetween } from '../../util/dates';\nimport { createSlug } from '../../util/urlHelpers';\nimport {\n  isTransactionInitiateAmountTooLowError,\n  isTransactionInitiateListingNotFoundError,\n  isTransactionInitiateMissingStripeAccountError,\n  isTransactionInitiateBookingTimeNotAvailableError,\n  isTransactionInitiateListingInsufficientStockError,\n  isTransactionChargeDisabledError,\n  isTransactionZeroPaymentError,\n  isTransitionQuantityInfoMissingError,\n  transactionInitiateOrderStripeErrors,\n} from '../../util/errors';\nimport { formatMoney } from '../../util/currency';\nimport {\n  TRANSITION_ENQUIRE,\n  txIsPaymentPending,\n  txIsPaymentExpired,\n  txHasPassedPaymentPending,\n} from '../../util/transaction';\n\n// Import global thunk functions\nimport { isScrollingDisabled } from '../../ducks/UI.duck';\nimport { confirmCardPayment, retrievePaymentIntent } from '../../ducks/stripe.duck';\nimport { savePaymentMethod } from '../../ducks/paymentMethods.duck';\n\n// Import shared components\nimport {\n  AvatarMedium,\n  AspectRatioWrapper,\n  OrderBreakdown,\n  Logo,\n  NamedLink,\n  NamedRedirect,\n  Page,\n  ResponsiveImage,\n} from '../../components';\n\n// Import modules from this directory\nimport {\n  initiateOrder,\n  setInitialValues,\n  speculateTransaction,\n  stripeCustomer,\n  confirmPayment,\n  sendMessage,\n} from './CheckoutPage.duck';\nimport StripePaymentForm from './StripePaymentForm/StripePaymentForm';\nimport { storeData, storedData, clearData } from './CheckoutPageSessionHelpers';\nimport css from './CheckoutPage.module.css';\n\nconst STORAGE_KEY = 'CheckoutPage';\n\n// Stripe PaymentIntent statuses, where user actions are already completed\n// https://stripe.com/docs/payments/payment-intents/status\nconst STRIPE_PI_USER_ACTIONS_DONE_STATUSES = ['processing', 'requires_capture', 'succeeded'];\n\n// Payment charge options\nconst ONETIME_PAYMENT = 'ONETIME_PAYMENT';\nconst PAY_AND_SAVE_FOR_LATER_USE = 'PAY_AND_SAVE_FOR_LATER_USE';\nconst USE_SAVED_CARD = 'USE_SAVED_CARD';\n\nconst paymentFlow = (selectedPaymentMethod, saveAfterOnetimePayment) => {\n  // Payment mode could be 'replaceCard', but without explicit saveAfterOnetimePayment flag,\n  // we'll handle it as one-time payment\n  return selectedPaymentMethod === 'defaultCard'\n    ? USE_SAVED_CARD\n    : saveAfterOnetimePayment\n    ? PAY_AND_SAVE_FOR_LATER_USE\n    : ONETIME_PAYMENT;\n};\n\nconst initializeOrderPage = (initialValues, routes, dispatch) => {\n  const OrderPage = findRouteByRouteName('OrderDetailsPage', routes);\n\n  // Transaction is already created, but if the initial message\n  // sending failed, we tell it to the OrderDetailsPage.\n  dispatch(OrderPage.setInitialValues(initialValues));\n};\n\nconst checkIsPaymentExpired = existingTransaction => {\n  return txIsPaymentExpired(existingTransaction)\n    ? true\n    : txIsPaymentPending(existingTransaction)\n    ? minutesBetween(existingTransaction.attributes.lastTransitionedAt, new Date()) >= 15\n    : false;\n};\n\nconst getFormattedTotalPrice = (transaction, intl) => {\n  const totalPrice = transaction.attributes.payinTotal;\n  return formatMoney(intl, totalPrice);\n};\n\n// Convert the picked date to moment that will represent the same time of day in UTC time zone.\nconst bookingDatesMaybe = bookingDates => {\n  const apiTimeZone = 'Etc/UTC';\n  return bookingDates\n    ? {\n        bookingDates: {\n          bookingStart: timeOfDayFromLocalToTimeZone(bookingDates.bookingStart, apiTimeZone),\n          bookingEnd: timeOfDayFromLocalToTimeZone(bookingDates.bookingEnd, apiTimeZone),\n        },\n      }\n    : {};\n};\n\n// Collect error message checks to a single function.\nconst getErrorMessages = (\n  listingNotFound,\n  initiateOrderError,\n  speculateTransactionError,\n  listingLink\n) => {\n  let listingNotFoundErrorMessage = null;\n  let initiateOrderErrorMessage = null;\n  let speculateErrorMessage = null;\n\n  const isAmountTooLowError = isTransactionInitiateAmountTooLowError(initiateOrderError);\n  const isChargeDisabledError = isTransactionChargeDisabledError(initiateOrderError);\n  const stripeErrors = transactionInitiateOrderStripeErrors(initiateOrderError);\n\n  // We want to show one error at a time for the real transition\n  if (listingNotFound) {\n    listingNotFoundErrorMessage = <FormattedMessage id=\"CheckoutPage.listingNotFoundError\" />;\n  } else if (isAmountTooLowError) {\n    initiateOrderErrorMessage = <FormattedMessage id=\"CheckoutPage.initiateOrderAmountTooLow\" />;\n  } else if (isTransactionInitiateBookingTimeNotAvailableError(initiateOrderError)) {\n    // If bookings are used, there could be error related to those\n    initiateOrderErrorMessage = (\n      <FormattedMessage id=\"CheckoutPage.bookingTimeNotAvailableMessage\" />\n    );\n  } else if (isTransitionQuantityInfoMissingError(initiateOrderError)) {\n    initiateOrderErrorMessage = (\n      <FormattedMessage id=\"CheckoutPage.correctQuantityInformationMissing\" />\n    );\n  } else if (isTransactionInitiateListingInsufficientStockError(initiateOrderError)) {\n    // If stock management is used, there could be error related to that\n    initiateOrderErrorMessage = <FormattedMessage id=\"CheckoutPage.notEnoughStockMessage\" />;\n  } else if (isChargeDisabledError) {\n    initiateOrderErrorMessage = <FormattedMessage id=\"CheckoutPage.chargeDisabledMessage\" />;\n  } else if (stripeErrors && stripeErrors.length > 0) {\n    // NOTE: Error messages from Stripes are not part of translations.\n    // By default they are in English.\n    const stripeErrorsAsString = stripeErrors.join(', ');\n    initiateOrderErrorMessage = (\n      <FormattedMessage\n        id=\"CheckoutPage.initiateOrderStripeError\"\n        values={{ stripeErrors: stripeErrorsAsString }}\n      />\n    );\n  } else if (initiateOrderError) {\n    // Generic initiate order error\n    initiateOrderErrorMessage = (\n      <FormattedMessage id=\"CheckoutPage.initiateOrderError\" values={{ listingLink }} />\n    );\n  }\n\n  // We want to show one error at a time for speculateTransition\n  if (isTransactionInitiateMissingStripeAccountError(speculateTransactionError)) {\n    speculateErrorMessage = (\n      <FormattedMessage id=\"CheckoutPage.providerStripeAccountMissingError\" />\n    );\n  } else if (isTransactionInitiateBookingTimeNotAvailableError(speculateTransactionError)) {\n    speculateErrorMessage = <FormattedMessage id=\"CheckoutPage.bookingTimeNotAvailableMessage\" />;\n  } else if (isTransactionInitiateListingInsufficientStockError(speculateTransactionError)) {\n    speculateErrorMessage = <FormattedMessage id=\"CheckoutPage.notEnoughStockMessage\" />;\n  } else if (isTransactionZeroPaymentError(speculateTransactionError)) {\n    speculateErrorMessage = <FormattedMessage id=\"CheckoutPage.initiateOrderAmountTooLow\" />;\n  } else if (isTransitionQuantityInfoMissingError(speculateTransactionError)) {\n    speculateErrorMessage = (\n      <FormattedMessage id=\"CheckoutPage.correctQuantityInformationMissing\" />\n    );\n  } else if (speculateTransactionError) {\n    speculateErrorMessage = <FormattedMessage id=\"CheckoutPage.speculateFailedMessage\" />;\n  }\n\n  // Add paragraph-container for the error message, if it exists\n  const listingNotFoundErrorMessageParagraph = listingNotFoundErrorMessage ? (\n    <p className={css.notFoundError}>{listingNotFoundErrorMessage}</p>\n  ) : null;\n  const initiateOrderErrorMessageParagraph = initiateOrderErrorMessage ? (\n    <p className={css.orderError}>{initiateOrderErrorMessage}</p>\n  ) : null;\n  const speculateErrorMessageParagraph = speculateErrorMessage ? (\n    <p className={css.orderError}>{speculateErrorMessage}</p>\n  ) : null;\n  const speculateTransactionErrorMessageParagraph = speculateTransactionError ? (\n    <p className={css.speculateError}>\n      <FormattedMessage id=\"CheckoutPage.speculateTransactionError\" />\n    </p>\n  ) : null;\n\n  return {\n    listingNotFoundErrorMessage: listingNotFoundErrorMessageParagraph,\n    initiateOrderErrorMessage: initiateOrderErrorMessageParagraph,\n    speculateErrorMessage: speculateErrorMessageParagraph,\n    speculateTransactionErrorMessage: speculateTransactionErrorMessageParagraph,\n  };\n};\n\nexport class CheckoutPageComponent extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      pageData: {},\n      dataLoaded: false,\n      submitting: false,\n    };\n    this.stripe = null;\n\n    this.onStripeInitialized = this.onStripeInitialized.bind(this);\n    this.loadInitialData = this.loadInitialData.bind(this);\n    this.handlePaymentIntent = this.handlePaymentIntent.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  componentDidMount() {\n    if (window) {\n      this.loadInitialData();\n    }\n  }\n\n  /**\n   * Load initial data for the page\n   *\n   * Since the data for the checkout is not passed in the URL (there\n   * might be lots of options in the future), we must pass in the data\n   * some other way. Currently the ListingPage sets the initial data\n   * for the CheckoutPage's Redux store.\n   *\n   * For some cases (e.g. a refresh in the CheckoutPage), the Redux\n   * store is empty. To handle that case, we store the received data\n   * to window.sessionStorage and read it from there if no props from\n   * the store exist.\n   *\n   * This function also sets of fetching the speculative transaction\n   * based on this initial data.\n   */\n  loadInitialData() {\n    const {\n      orderData,\n      listing,\n      transaction,\n      fetchSpeculatedTransaction,\n      fetchStripeCustomer,\n      history,\n    } = this.props;\n\n    // Fetch currentUser with stripeCustomer entity\n    // Note: since there's need for data loading in \"componentWillMount\" function,\n    //       this is added here instead of loadData static function.\n    fetchStripeCustomer();\n\n    // Browser's back navigation should not rewrite data in session store.\n    // Action is 'POP' on both history.back() and page refresh cases.\n    // Action is 'PUSH' when user has directed through a link\n    // Action is 'REPLACE' when user has directed through login/signup process\n    const hasNavigatedThroughLink = history.action === 'PUSH' || history.action === 'REPLACE';\n\n    const hasDataInProps = !!(orderData && listing && hasNavigatedThroughLink);\n    if (hasDataInProps) {\n      // Store data only if data is passed through props and user has navigated through a link.\n      storeData(orderData, listing, transaction, STORAGE_KEY);\n    }\n\n    // NOTE: stored data can be empty if user has already successfully completed transaction.\n    const pageData = hasDataInProps ? { orderData, listing, transaction } : storedData(STORAGE_KEY);\n\n    const tx = pageData ? pageData.transaction : null;\n\n    // If transaction has passed payment-pending state, speculated tx is not needed.\n    const shouldFetchSpeculatedTransaction =\n      pageData &&\n      pageData.listing &&\n      pageData.listing.id &&\n      pageData.orderData &&\n      !txHasPassedPaymentPending(tx);\n\n    if (shouldFetchSpeculatedTransaction) {\n      const listingId = pageData.listing.id;\n      const transactionId = tx ? tx.id : null;\n\n      // Fetch speculated transaction for showing price in order breakdown\n      // NOTE: if unit type is line-item/units, quantity needs to be added.\n      // The way to pass it to checkout page is through pageData.orderData\n      const quantity = pageData.orderData?.quantity;\n      const quantityMaybe = quantity ? { quantity } : {};\n      const deliveryMethod = pageData.orderData?.deliveryMethod;\n      fetchSpeculatedTransaction(\n        {\n          listingId,\n          deliveryMethod,\n          ...quantityMaybe,\n          ...bookingDatesMaybe(pageData.orderData.bookingDates),\n        },\n        transactionId\n      );\n    }\n\n    this.setState({ pageData: pageData || {}, dataLoaded: true });\n  }\n\n  handlePaymentIntent(handlePaymentParams) {\n    const {\n      currentUser,\n      stripeCustomerFetched,\n      onInitiateOrder,\n      onConfirmCardPayment,\n      onConfirmPayment,\n      onSendMessage,\n      onSavePaymentMethod,\n    } = this.props;\n    const {\n      pageData,\n      speculatedTransaction,\n      message,\n      paymentIntent,\n      selectedPaymentMethod,\n      saveAfterOnetimePayment,\n      shippingDetails,\n    } = handlePaymentParams;\n    const storedTx = ensureTransaction(pageData.transaction);\n\n    const ensuredCurrentUser = ensureCurrentUser(currentUser);\n    const ensuredStripeCustomer = ensureStripeCustomer(ensuredCurrentUser.stripeCustomer);\n    const ensuredDefaultPaymentMethod = ensurePaymentMethodCard(\n      ensuredStripeCustomer.defaultPaymentMethod\n    );\n\n    let createdPaymentIntent = null;\n\n    const hasDefaultPaymentMethod = !!(\n      stripeCustomerFetched &&\n      ensuredStripeCustomer.attributes.stripeCustomerId &&\n      ensuredDefaultPaymentMethod.id\n    );\n    const stripePaymentMethodId = hasDefaultPaymentMethod\n      ? ensuredDefaultPaymentMethod.attributes.stripePaymentMethodId\n      : null;\n\n    const selectedPaymentFlow = paymentFlow(selectedPaymentMethod, saveAfterOnetimePayment);\n\n    // Step 1: initiate order by requesting payment from Marketplace API\n    const fnRequestPayment = fnParams => {\n      // fnParams should be { listingId, deliveryMethod, quantity?, bookingDates?, paymentMethod?/setupPaymentMethodForSaving? }\n      const hasPaymentIntents =\n        storedTx.attributes.protectedData && storedTx.attributes.protectedData.stripePaymentIntents;\n\n      // If paymentIntent exists, order has been initiated previously.\n      return hasPaymentIntents ? Promise.resolve(storedTx) : onInitiateOrder(fnParams, storedTx.id);\n    };\n\n    // Step 2: pay using Stripe SDK\n    const fnConfirmCardPayment = fnParams => {\n      // fnParams should be returned transaction entity\n\n      const order = ensureTransaction(fnParams);\n      if (order.id) {\n        // Store order.\n        const { orderData, listing } = pageData;\n        storeData(orderData, listing, order, STORAGE_KEY);\n        this.setState({ pageData: { ...pageData, transaction: order } });\n      }\n\n      const hasPaymentIntents =\n        order.attributes.protectedData && order.attributes.protectedData.stripePaymentIntents;\n\n      if (!hasPaymentIntents) {\n        throw new Error(\n          `Missing StripePaymentIntents key in transaction's protectedData. Check that your transaction process is configured to use payment intents.`\n        );\n      }\n\n      const { stripePaymentIntentClientSecret } = hasPaymentIntents\n        ? order.attributes.protectedData.stripePaymentIntents.default\n        : null;\n\n      const { stripe, card, billingDetails, paymentIntent } = handlePaymentParams;\n      const stripeElementMaybe = selectedPaymentFlow !== USE_SAVED_CARD ? { card } : {};\n\n      // Note: For basic USE_SAVED_CARD scenario, we have set it already on API side, when PaymentIntent was created.\n      // However, the payment_method is save here for USE_SAVED_CARD flow if customer first attempted onetime payment\n      const paymentParams =\n        selectedPaymentFlow !== USE_SAVED_CARD\n          ? {\n              payment_method: {\n                billing_details: billingDetails,\n                card: card,\n              },\n            }\n          : { payment_method: stripePaymentMethodId };\n\n      const params = {\n        stripePaymentIntentClientSecret,\n        orderId: order.id,\n        stripe,\n        ...stripeElementMaybe,\n        paymentParams,\n      };\n\n      // If paymentIntent status is not waiting user action,\n      // confirmCardPayment has been called previously.\n      const hasPaymentIntentUserActionsDone =\n        paymentIntent && STRIPE_PI_USER_ACTIONS_DONE_STATUSES.includes(paymentIntent.status);\n      return hasPaymentIntentUserActionsDone\n        ? Promise.resolve({ transactionId: order.id, paymentIntent })\n        : onConfirmCardPayment(params);\n    };\n\n    // Step 3: complete order by confirming payment to Marketplace API\n    // Parameter should contain { paymentIntent, transactionId } returned in step 2\n    const fnConfirmPayment = fnParams => {\n      createdPaymentIntent = fnParams.paymentIntent;\n      return onConfirmPayment(fnParams);\n    };\n\n    // Step 4: send initial message\n    const fnSendMessage = fnParams => {\n      return onSendMessage({ ...fnParams, message });\n    };\n\n    // Step 5: optionally save card as defaultPaymentMethod\n    const fnSavePaymentMethod = fnParams => {\n      const pi = createdPaymentIntent || paymentIntent;\n\n      if (selectedPaymentFlow === PAY_AND_SAVE_FOR_LATER_USE) {\n        return onSavePaymentMethod(ensuredStripeCustomer, pi.payment_method)\n          .then(response => {\n            if (response.errors) {\n              return { ...fnParams, paymentMethodSaved: false };\n            }\n            return { ...fnParams, paymentMethodSaved: true };\n          })\n          .catch(e => {\n            // Real error cases are catched already in paymentMethods page.\n            return { ...fnParams, paymentMethodSaved: false };\n          });\n      } else {\n        return Promise.resolve({ ...fnParams, paymentMethodSaved: true });\n      }\n    };\n\n    // Here we create promise calls in sequence\n    // This is pretty much the same as:\n    // fnRequestPayment({...initialParams})\n    //   .then(result => fnConfirmCardPayment({...result}))\n    //   .then(result => fnConfirmPayment({...result}))\n    const applyAsync = (acc, val) => acc.then(val);\n    const composeAsync = (...funcs) => x => funcs.reduce(applyAsync, Promise.resolve(x));\n    const handlePaymentIntentCreation = composeAsync(\n      fnRequestPayment,\n      fnConfirmCardPayment,\n      fnConfirmPayment,\n      fnSendMessage,\n      fnSavePaymentMethod\n    );\n\n    // Create order aka transaction\n    // NOTE: if unit type is line-item/units, quantity needs to be added.\n    // The way to pass it to checkout page is through pageData.orderData\n    const tx = speculatedTransaction ? speculatedTransaction : storedTx;\n\n    const deliveryMethod = pageData.orderData?.deliveryMethod;\n    const quantity = pageData.orderData?.quantity;\n    const quantityMaybe = quantity ? { quantity } : {};\n    const protectedDataMaybe =\n      deliveryMethod && shippingDetails\n        ? { protectedData: { deliveryMethod, shippingDetails } }\n        : deliveryMethod\n        ? { protectedData: { deliveryMethod } }\n        : {};\n    // Note: optionalPaymentParams contains Stripe paymentMethod,\n    // but that can also be passed on Step 2\n    // stripe.confirmCardPayment(stripe, { payment_method: stripePaymentMethodId })\n    const optionalPaymentParams =\n      selectedPaymentFlow === USE_SAVED_CARD && hasDefaultPaymentMethod\n        ? { paymentMethod: stripePaymentMethodId }\n        : selectedPaymentFlow === PAY_AND_SAVE_FOR_LATER_USE\n        ? { setupPaymentMethodForSaving: true }\n        : {};\n\n    const orderParams = {\n      listingId: pageData.listing.id,\n      deliveryMethod,\n      ...quantityMaybe,\n      ...bookingDatesMaybe(pageData.orderData.bookingDates),\n      ...protectedDataMaybe,\n      ...optionalPaymentParams,\n    };\n\n    return handlePaymentIntentCreation(orderParams);\n  }\n\n  handleSubmit(values) {\n    if (this.state.submitting) {\n      return;\n    }\n    this.setState({ submitting: true });\n\n    const { history, speculatedTransaction, currentUser, paymentIntent, dispatch } = this.props;\n    const { card, message, paymentMethod, formValues } = values;\n    const {\n      name,\n      addressLine1,\n      addressLine2,\n      postal,\n      city,\n      state,\n      country,\n      saveAfterOnetimePayment,\n      recipientName,\n      recipientPhoneNumber,\n      recipientAddressLine1,\n      recipientAddressLine2,\n      recipientPostal,\n      recipientCity,\n      recipientState,\n      recipientCountry,\n    } = formValues;\n\n    // Billing address is recommended.\n    // However, let's not assume that <StripePaymentAddress> data is among formValues.\n    // Read more about this from Stripe's docs\n    // https://stripe.com/docs/stripe-js/reference#stripe-handle-card-payment-no-element\n    const addressMaybe =\n      addressLine1 && postal\n        ? {\n            address: {\n              city: city,\n              country: country,\n              line1: addressLine1,\n              line2: addressLine2,\n              postal_code: postal,\n              state: state,\n            },\n          }\n        : {};\n    const billingDetails = {\n      name,\n      email: ensureCurrentUser(currentUser).attributes.email,\n      ...addressMaybe,\n    };\n\n    const shippingDetailsMaybe =\n      recipientName && recipientAddressLine1 && recipientPostal\n        ? {\n            shippingDetails: {\n              name: recipientName,\n              phoneNumber: recipientPhoneNumber,\n              address: {\n                city: recipientCity,\n                country: recipientCountry,\n                line1: recipientAddressLine1,\n                line2: recipientAddressLine2,\n                postalCode: recipientPostal,\n                state: recipientState,\n              },\n            },\n          }\n        : {};\n    const requestPaymentParams = {\n      pageData: this.state.pageData,\n      speculatedTransaction,\n      stripe: this.stripe,\n      card,\n      billingDetails,\n      message,\n      paymentIntent,\n      selectedPaymentMethod: paymentMethod,\n      saveAfterOnetimePayment:\n        Array.isArray(saveAfterOnetimePayment) && saveAfterOnetimePayment.length > 0,\n      ...shippingDetailsMaybe,\n    };\n\n    this.handlePaymentIntent(requestPaymentParams)\n      .then(res => {\n        const { orderId, messageSuccess, paymentMethodSaved } = res;\n        this.setState({ submitting: false });\n\n        const routes = routeConfiguration();\n        const initialMessageFailedToTransaction = messageSuccess ? null : orderId;\n        const orderDetailsPath = pathByRouteName('OrderDetailsPage', routes, { id: orderId.uuid });\n        const initialValues = {\n          initialMessageFailedToTransaction,\n          savePaymentMethodFailed: !paymentMethodSaved,\n        };\n\n        initializeOrderPage(initialValues, routes, dispatch);\n        clearData(STORAGE_KEY);\n        history.push(orderDetailsPath);\n      })\n      .catch(err => {\n        console.error(err);\n        this.setState({ submitting: false });\n      });\n  }\n\n  onStripeInitialized(stripe) {\n    this.stripe = stripe;\n\n    const { paymentIntent, onRetrievePaymentIntent } = this.props;\n    const tx = this.state.pageData ? this.state.pageData.transaction : null;\n\n    // We need to get up to date PI, if payment is pending but it's not expired.\n    const shouldFetchPaymentIntent =\n      this.stripe &&\n      !paymentIntent &&\n      tx &&\n      tx.id &&\n      txIsPaymentPending(tx) &&\n      !checkIsPaymentExpired(tx);\n\n    if (shouldFetchPaymentIntent) {\n      const { stripePaymentIntentClientSecret } =\n        tx.attributes.protectedData && tx.attributes.protectedData.stripePaymentIntents\n          ? tx.attributes.protectedData.stripePaymentIntents.default\n          : {};\n\n      // Fetch up to date PaymentIntent from Stripe\n      onRetrievePaymentIntent({ stripe, stripePaymentIntentClientSecret });\n    }\n  }\n\n  render() {\n    const {\n      scrollingDisabled,\n      speculateTransactionInProgress,\n      speculateTransactionError,\n      speculatedTransaction: speculatedTransactionMaybe,\n      initiateOrderError,\n      confirmPaymentError,\n      intl,\n      params,\n      currentUser,\n      confirmCardPaymentError,\n      paymentIntent,\n      retrievePaymentIntentError,\n      stripeCustomerFetched,\n    } = this.props;\n\n    // Since the listing data is already given from the ListingPage\n    // and stored to handle refreshes, it might not have the possible\n    // deleted or closed information in it. If the transaction\n    // initiate or the speculative initiate fail due to the listing\n    // being deleted or closec, we should dig the information from the\n    // errors and not the listing data.\n    const listingNotFound =\n      isTransactionInitiateListingNotFoundError(speculateTransactionError) ||\n      isTransactionInitiateListingNotFoundError(initiateOrderError);\n\n    const isLoading = !this.state.dataLoaded || speculateTransactionInProgress;\n\n    const { listing, transaction, orderData } = this.state.pageData;\n    const existingTransaction = ensureTransaction(transaction);\n    const speculatedTransaction = ensureTransaction(speculatedTransactionMaybe, {}, null);\n    const currentListing = ensureListing(listing);\n    const currentAuthor = ensureUser(currentListing.author);\n\n    const listingTitle = currentListing.attributes.title;\n    const title = intl.formatMessage({ id: 'CheckoutPage.title' }, { listingTitle });\n\n    const pageProps = { title, scrollingDisabled };\n    const topbar = (\n      <div className={css.topbar}>\n        <NamedLink className={css.home} name=\"LandingPage\">\n          <Logo\n            className={css.logoMobile}\n            title={intl.formatMessage({ id: 'CheckoutPage.goToLandingPage' })}\n            format=\"mobile\"\n          />\n          <Logo\n            className={css.logoDesktop}\n            alt={intl.formatMessage({ id: 'CheckoutPage.goToLandingPage' })}\n            format=\"desktop\"\n          />\n        </NamedLink>\n      </div>\n    );\n\n    if (isLoading) {\n      return <Page {...pageProps}>{topbar}</Page>;\n    }\n\n    const isOwnListing =\n      currentUser &&\n      currentUser.id &&\n      currentAuthor &&\n      currentAuthor.id &&\n      currentAuthor.id.uuid === currentUser.id.uuid;\n\n    const hasRequiredData = !!(currentListing.id && currentAuthor.id);\n    const canShowPage = hasRequiredData && !isOwnListing;\n    const shouldRedirect = !isLoading && !canShowPage;\n\n    // Redirect back to ListingPage if data is missing.\n    // Redirection must happen before any data format error is thrown (e.g. wrong currency)\n    if (shouldRedirect) {\n      // eslint-disable-next-line no-console\n      console.error('Missing or invalid data for checkout, redirecting back to listing page.', {\n        transaction: speculatedTransaction,\n        listing,\n      });\n      return <NamedRedirect name=\"ListingPage\" params={params} />;\n    }\n\n    // Show breakdown only when (speculated?) transaction is loaded\n    // (i.e. have an id and lineItems)\n    const tx = existingTransaction.booking ? existingTransaction : speculatedTransaction;\n    const txBookingMaybe = tx.booking?.id\n      ? { booking: ensureBooking(tx.booking), dateType: DATE_TYPE_DATE }\n      : {};\n    const breakdown =\n      tx.id && tx.attributes.lineItems?.length > 0 ? (\n        <OrderBreakdown\n          className={css.orderBreakdown}\n          userRole=\"customer\"\n          unitType={config.lineItemUnitType}\n          transaction={tx}\n          {...txBookingMaybe}\n        />\n      ) : null;\n\n    const isPaymentExpired = checkIsPaymentExpired(existingTransaction);\n    const hasDefaultPaymentMethod = !!(\n      stripeCustomerFetched &&\n      ensureStripeCustomer(currentUser.stripeCustomer).attributes.stripeCustomerId &&\n      ensurePaymentMethodCard(currentUser.stripeCustomer.defaultPaymentMethod).id\n    );\n\n    // Allow showing page when currentUser is still being downloaded,\n    // but show payment form only when user info is loaded.\n    const showPaymentForm = !!(\n      currentUser &&\n      hasRequiredData &&\n      !listingNotFound &&\n      !initiateOrderError &&\n      !speculateTransactionError &&\n      !retrievePaymentIntentError &&\n      !isPaymentExpired\n    );\n\n    const firstImage =\n      currentListing.images && currentListing.images.length > 0 ? currentListing.images[0] : null;\n\n    const { aspectWidth = 1, aspectHeight = 1, variantPrefix = 'listing-card' } = config.listing;\n    const variants = firstImage\n      ? Object.keys(firstImage?.attributes?.variants).filter(k => k.startsWith(variantPrefix))\n      : [];\n\n    const listingLink = (\n      <NamedLink\n        name=\"ListingPage\"\n        params={{ id: currentListing.id.uuid, slug: createSlug(listingTitle) }}\n      >\n        <FormattedMessage id=\"CheckoutPage.errorlistingLinkText\" />\n      </NamedLink>\n    );\n\n    const {\n      listingNotFoundErrorMessage,\n      initiateOrderErrorMessage,\n      speculateErrorMessage,\n      speculateTransactionErrorMessage,\n    } = getErrorMessages(\n      listingNotFound,\n      initiateOrderError,\n      speculateTransactionError,\n      listingLink\n    );\n\n    const unitType = config.lineItemUnitType;\n    const isNightly = unitType === LINE_ITEM_NIGHT;\n    const isDaily = unitType === LINE_ITEM_DAY;\n\n    const unitTranslationKey = isNightly\n      ? 'CheckoutPage.perNight'\n      : isDaily\n      ? 'CheckoutPage.perDay'\n      : 'CheckoutPage.perUnit';\n\n    const price = currentListing.attributes.price;\n    const formattedPrice = formatMoney(intl, price);\n    const detailsSubTitle = `${formattedPrice} ${intl.formatMessage({ id: unitTranslationKey })}`;\n\n    const showInitialMessageInput = !(\n      existingTransaction && existingTransaction.attributes.lastTransition === TRANSITION_ENQUIRE\n    );\n\n    // Get first and last name of the current user and use it in the StripePaymentForm to autofill the name field\n    const userName =\n      currentUser && currentUser.attributes\n        ? `${currentUser.attributes.profile.firstName} ${currentUser.attributes.profile.lastName}`\n        : null;\n\n    // If paymentIntent status is not waiting user action,\n    // confirmCardPayment has been called previously.\n    const hasPaymentIntentUserActionsDone =\n      paymentIntent && STRIPE_PI_USER_ACTIONS_DONE_STATUSES.includes(paymentIntent.status);\n\n    // If your marketplace works mostly in one country you can use initial values to select country automatically\n    // e.g. {country: 'FI'}\n\n    const initalValuesForStripePayment = { name: userName, recipientName: userName };\n\n    return (\n      <Page {...pageProps}>\n        {topbar}\n        <div className={css.contentContainer}>\n          <AspectRatioWrapper\n            width={aspectWidth}\n            height={aspectHeight}\n            className={css.aspectWrapper}\n          >\n            <ResponsiveImage\n              rootClassName={css.rootForImage}\n              alt={listingTitle}\n              image={firstImage}\n              variants={variants}\n            />\n          </AspectRatioWrapper>\n          <div className={classNames(css.avatarWrapper, css.avatarMobile)}>\n            <AvatarMedium user={currentAuthor} disableProfileLink />\n          </div>\n          <div className={css.bookListingContainer}>\n            <div className={css.heading}>\n              <h1 className={css.title}>{title}</h1>\n              <div className={css.author}>\n                <FormattedMessage\n                  id=\"CheckoutPage.providerInfo\"\n                  values={{ name: currentAuthor.attributes.profile.displayName }}\n                />\n              </div>\n            </div>\n\n            <div className={css.priceBreakdownContainer}>\n              {speculateTransactionErrorMessage}\n              {breakdown}\n            </div>\n\n            <section className={css.paymentContainer}>\n              {initiateOrderErrorMessage}\n              {listingNotFoundErrorMessage}\n              {speculateErrorMessage}\n              {retrievePaymentIntentError ? (\n                <p className={css.orderError}>\n                  <FormattedMessage\n                    id=\"CheckoutPage.retrievingStripePaymentIntentFailed\"\n                    values={{ listingLink }}\n                  />\n                </p>\n              ) : null}\n              {showPaymentForm ? (\n                <StripePaymentForm\n                  className={css.paymentForm}\n                  onSubmit={this.handleSubmit}\n                  inProgress={this.state.submitting}\n                  formId=\"CheckoutPagePaymentForm\"\n                  authorDisplayName={currentAuthor.attributes.profile.displayName}\n                  showInitialMessageInput={showInitialMessageInput}\n                  initialValues={initalValuesForStripePayment}\n                  initiateOrderError={initiateOrderError}\n                  confirmCardPaymentError={confirmCardPaymentError}\n                  confirmPaymentError={confirmPaymentError}\n                  hasHandledCardPayment={hasPaymentIntentUserActionsDone}\n                  loadingData={!stripeCustomerFetched}\n                  defaultPaymentMethod={\n                    hasDefaultPaymentMethod ? currentUser.stripeCustomer.defaultPaymentMethod : null\n                  }\n                  paymentIntent={paymentIntent}\n                  onStripeInitialized={this.onStripeInitialized}\n                  askShippingDetails={orderData?.deliveryMethod === 'shipping'}\n                  pickupLocation={currentListing?.attributes?.publicData?.location}\n                  totalPrice={tx.id ? getFormattedTotalPrice(tx, intl) : null}\n                />\n              ) : null}\n              {isPaymentExpired ? (\n                <p className={css.orderError}>\n                  <FormattedMessage\n                    id=\"CheckoutPage.paymentExpiredMessage\"\n                    values={{ listingLink }}\n                  />\n                </p>\n              ) : null}\n            </section>\n          </div>\n\n          <div className={css.detailsContainerDesktop}>\n            <AspectRatioWrapper\n              width={aspectWidth}\n              height={aspectHeight}\n              className={css.detailsAspectWrapper}\n            >\n              <ResponsiveImage\n                rootClassName={css.rootForImage}\n                alt={listingTitle}\n                image={firstImage}\n                variants={variants}\n              />\n            </AspectRatioWrapper>\n            <div className={css.avatarWrapper}>\n              <AvatarMedium user={currentAuthor} disableProfileLink />\n            </div>\n            <div className={css.detailsHeadings}>\n              <h2 className={css.detailsTitle}>{listingTitle}</h2>\n              <p className={css.detailsSubtitle}>{detailsSubTitle}</p>\n            </div>\n            {speculateTransactionErrorMessage}\n            <h2 className={css.orderBreakdownTitle}>\n              <FormattedMessage id=\"CheckoutPage.orderBreakdown\" />\n            </h2>\n            {breakdown}\n          </div>\n        </div>\n      </Page>\n    );\n  }\n}\n\nCheckoutPageComponent.defaultProps = {\n  initiateOrderError: null,\n  confirmPaymentError: null,\n  listing: null,\n  orderData: {},\n  speculateTransactionError: null,\n  speculatedTransaction: null,\n  transaction: null,\n  currentUser: null,\n  paymentIntent: null,\n};\n\nCheckoutPageComponent.propTypes = {\n  scrollingDisabled: bool.isRequired,\n  listing: propTypes.listing,\n  orderData: object,\n  fetchStripeCustomer: func.isRequired,\n  stripeCustomerFetched: bool.isRequired,\n  fetchSpeculatedTransaction: func.isRequired,\n  speculateTransactionInProgress: bool.isRequired,\n  speculateTransactionError: propTypes.error,\n  speculatedTransaction: propTypes.transaction,\n  transaction: propTypes.transaction,\n  currentUser: propTypes.currentUser,\n  params: shape({\n    id: string,\n    slug: string,\n  }).isRequired,\n  onConfirmPayment: func.isRequired,\n  onInitiateOrder: func.isRequired,\n  onConfirmCardPayment: func.isRequired,\n  onRetrievePaymentIntent: func.isRequired,\n  onSavePaymentMethod: func.isRequired,\n  onSendMessage: func.isRequired,\n  initiateOrderError: propTypes.error,\n  confirmPaymentError: propTypes.error,\n  // confirmCardPaymentError comes from Stripe so that's why we can't expect it to be in a specific form\n  confirmCardPaymentError: oneOfType([propTypes.error, object]),\n  paymentIntent: object,\n\n  // from connect\n  dispatch: func.isRequired,\n\n  // from injectIntl\n  intl: intlShape.isRequired,\n\n  // from withRouter\n  history: shape({\n    push: func.isRequired,\n  }).isRequired,\n};\n\nconst mapStateToProps = state => {\n  const {\n    listing,\n    orderData,\n    stripeCustomerFetched,\n    speculateTransactionInProgress,\n    speculateTransactionError,\n    speculatedTransaction,\n    transaction,\n    initiateOrderError,\n    confirmPaymentError,\n  } = state.CheckoutPage;\n  const { currentUser } = state.user;\n  const { confirmCardPaymentError, paymentIntent, retrievePaymentIntentError } = state.stripe;\n  return {\n    scrollingDisabled: isScrollingDisabled(state),\n    currentUser,\n    stripeCustomerFetched,\n    orderData,\n    speculateTransactionInProgress,\n    speculateTransactionError,\n    speculatedTransaction,\n    transaction,\n    listing,\n    initiateOrderError,\n    confirmCardPaymentError,\n    confirmPaymentError,\n    paymentIntent,\n    retrievePaymentIntentError,\n  };\n};\n\nconst mapDispatchToProps = dispatch => ({\n  dispatch,\n  fetchSpeculatedTransaction: (params, transactionId) =>\n    dispatch(speculateTransaction(params, transactionId)),\n  fetchStripeCustomer: () => dispatch(stripeCustomer()),\n  onInitiateOrder: (params, transactionId) => dispatch(initiateOrder(params, transactionId)),\n  onRetrievePaymentIntent: params => dispatch(retrievePaymentIntent(params)),\n  onConfirmCardPayment: params => dispatch(confirmCardPayment(params)),\n  onConfirmPayment: params => dispatch(confirmPayment(params)),\n  onSendMessage: params => dispatch(sendMessage(params)),\n  onSavePaymentMethod: (stripeCustomer, stripePaymentMethodId) =>\n    dispatch(savePaymentMethod(stripeCustomer, stripePaymentMethodId)),\n});\n\nconst CheckoutPage = compose(\n  withRouter,\n  connect(\n    mapStateToProps,\n    mapDispatchToProps\n  ),\n  injectIntl\n)(CheckoutPageComponent);\n\nCheckoutPage.setInitialValues = (initialValues, saveToSessionStorage = false) => {\n  if (saveToSessionStorage) {\n    const { listing, orderData } = initialValues;\n    storeData(orderData, listing, null, STORAGE_KEY);\n  }\n\n  return setInitialValues(initialValues);\n};\n\nCheckoutPage.displayName = 'CheckoutPage';\n\nexport default CheckoutPage;\n"]},"metadata":{},"sourceType":"module"}