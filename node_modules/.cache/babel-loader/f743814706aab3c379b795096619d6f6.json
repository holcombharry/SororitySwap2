{"ast":null,"code":"import { types as sdkTypes } from '../../util/sdkLoader';\nimport { userLocation } from '../../util/maps';\nimport config from '../../config';\nconst {\n  LatLng: SDKLatLng,\n  LatLngBounds: SDKLatLngBounds\n} = sdkTypes;\nexport const CURRENT_LOCATION_ID = 'current-location';\nconst GENERATED_BOUNDS_DEFAULT_DISTANCE = 500; // meters\n// Distances for generated bounding boxes for different Mapbox place types\n\nconst PLACE_TYPE_BOUNDS_DISTANCES = {\n  address: 500,\n  country: 2000,\n  region: 2000,\n  postcode: 2000,\n  district: 2000,\n  place: 2000,\n  locality: 2000,\n  neighborhood: 2000,\n  poi: 2000,\n  'poi.landmark': 2000\n};\n\nconst locationBounds = (latlng, distance) => {\n  if (!latlng) {\n    return null;\n  }\n\n  const bounds = new window.mapboxgl.LngLat(latlng.lng, latlng.lat).toBounds(distance);\n  return new SDKLatLngBounds(new SDKLatLng(bounds.getNorth(), bounds.getEast()), new SDKLatLng(bounds.getSouth(), bounds.getWest()));\n};\n\nconst placeOrigin = prediction => {\n  if (prediction && Array.isArray(prediction.center) && prediction.center.length === 2) {\n    // Coordinates in Mapbox features are represented as [longitude, latitude].\n    return new SDKLatLng(prediction.center[1], prediction.center[0]);\n  }\n\n  return null;\n};\n\nconst placeBounds = prediction => {\n  if (prediction) {\n    if (Array.isArray(prediction.bbox) && prediction.bbox.length === 4) {\n      // Bounds in Mapbox features are represented as [minX, minY, maxX, maxY]\n      return new SDKLatLngBounds(new SDKLatLng(prediction.bbox[3], prediction.bbox[2]), new SDKLatLng(prediction.bbox[1], prediction.bbox[0]));\n    } else {\n      // If bounds are not available, generate them around the origin\n      // Resolve bounds distance based on place type\n      const placeType = Array.isArray(prediction.place_type) && prediction.place_type[0];\n      const distance = placeType && PLACE_TYPE_BOUNDS_DISTANCES[placeType] || GENERATED_BOUNDS_DEFAULT_DISTANCE;\n      return locationBounds(placeOrigin(prediction), distance);\n    }\n  }\n\n  return null;\n};\n\nexport const GeocoderAttribution = () => null;\n/**\n * A forward geocoding (place name -> coordinates) implementation\n * using the Mapbox Geocoding API.\n */\n\n_c = GeocoderAttribution;\n\nclass GeocoderMapbox {\n  getClient() {\n    const libLoaded = typeof window !== 'undefined' && window.mapboxgl && window.mapboxSdk;\n\n    if (!libLoaded) {\n      throw new Error('Mapbox libraries are required for GeocoderMapbox');\n    }\n\n    if (!this._client) {\n      this._client = window.mapboxSdk({\n        accessToken: window.mapboxgl.accessToken\n      });\n    }\n\n    return this._client;\n  } // Public API\n  //\n\n  /**\n   * Search places with the given name.\n   *\n   * @param {String} search query for place names\n   *\n   * @return {Promise<{ search: String, predictions: Array<Object>}>}\n   * results of the geocoding, should have the original search query\n   * and an array of predictions. The format of the predictions is\n   * only relevant for the `getPlaceDetails` function below.\n   */\n\n\n  getPlacePredictions(search) {\n    const limitCountriesMaybe = config.maps.search.countryLimit ? {\n      countries: config.maps.search.countryLimit\n    } : {};\n    return this.getClient().geocoding.forwardGeocode({\n      query: search,\n      limit: 5,\n      ...limitCountriesMaybe,\n      language: [config.locale]\n    }).send().then(response => {\n      return {\n        search,\n        predictions: response.body.features\n      };\n    });\n  }\n  /**\n   * Get the ID of the given prediction.\n   */\n\n\n  getPredictionId(prediction) {\n    return prediction.id;\n  }\n  /**\n   * Get the address text of the given prediction.\n   */\n\n\n  getPredictionAddress(prediction) {\n    if (prediction.predictionPlace) {\n      // default prediction defined above\n      return prediction.predictionPlace.address;\n    } // prediction from Mapbox geocoding API\n\n\n    return prediction.place_name;\n  }\n  /**\n   * Fetch or read place details from the selected prediction.\n   *\n   * @param {Object} prediction selected prediction object\n   *\n   * @return {Promise<util.propTypes.place>} a place object\n   */\n\n\n  getPlaceDetails(prediction) {\n    if (this.getPredictionId(prediction) === CURRENT_LOCATION_ID) {\n      return userLocation().then(latlng => {\n        return {\n          address: '',\n          origin: latlng,\n          bounds: locationBounds(latlng, config.maps.search.currentLocationBoundsDistance)\n        };\n      });\n    }\n\n    if (prediction.predictionPlace) {\n      return Promise.resolve(prediction.predictionPlace);\n    }\n\n    return Promise.resolve({\n      address: this.getPredictionAddress(prediction),\n      origin: placeOrigin(prediction),\n      bounds: placeBounds(prediction)\n    });\n  }\n\n}\n\nexport default GeocoderMapbox;\n\nvar _c;\n\n$RefreshReg$(_c, \"GeocoderAttribution\");","map":{"version":3,"sources":["/Users/harryholcomb/Desktop/React Native/GitHub/Sharetribe/ftw-product/src/components/LocationAutocompleteInput/GeocoderMapbox.js"],"names":["types","sdkTypes","userLocation","config","LatLng","SDKLatLng","LatLngBounds","SDKLatLngBounds","CURRENT_LOCATION_ID","GENERATED_BOUNDS_DEFAULT_DISTANCE","PLACE_TYPE_BOUNDS_DISTANCES","address","country","region","postcode","district","place","locality","neighborhood","poi","locationBounds","latlng","distance","bounds","window","mapboxgl","LngLat","lng","lat","toBounds","getNorth","getEast","getSouth","getWest","placeOrigin","prediction","Array","isArray","center","length","placeBounds","bbox","placeType","place_type","GeocoderAttribution","GeocoderMapbox","getClient","libLoaded","mapboxSdk","Error","_client","accessToken","getPlacePredictions","search","limitCountriesMaybe","maps","countryLimit","countries","geocoding","forwardGeocode","query","limit","language","locale","send","then","response","predictions","body","features","getPredictionId","id","getPredictionAddress","predictionPlace","place_name","getPlaceDetails","origin","currentLocationBoundsDistance","Promise","resolve"],"mappings":"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","sourcesContent":["import { types as sdkTypes } from '../../util/sdkLoader';\nimport { userLocation } from '../../util/maps';\nimport config from '../../config';\n\nconst { LatLng: SDKLatLng, LatLngBounds: SDKLatLngBounds } = sdkTypes;\n\nexport const CURRENT_LOCATION_ID = 'current-location';\n\nconst GENERATED_BOUNDS_DEFAULT_DISTANCE = 500; // meters\n// Distances for generated bounding boxes for different Mapbox place types\nconst PLACE_TYPE_BOUNDS_DISTANCES = {\n  address: 500,\n  country: 2000,\n  region: 2000,\n  postcode: 2000,\n  district: 2000,\n  place: 2000,\n  locality: 2000,\n  neighborhood: 2000,\n  poi: 2000,\n  'poi.landmark': 2000,\n};\n\nconst locationBounds = (latlng, distance) => {\n  if (!latlng) {\n    return null;\n  }\n\n  const bounds = new window.mapboxgl.LngLat(latlng.lng, latlng.lat).toBounds(distance);\n  return new SDKLatLngBounds(\n    new SDKLatLng(bounds.getNorth(), bounds.getEast()),\n    new SDKLatLng(bounds.getSouth(), bounds.getWest())\n  );\n};\n\nconst placeOrigin = prediction => {\n  if (prediction && Array.isArray(prediction.center) && prediction.center.length === 2) {\n    // Coordinates in Mapbox features are represented as [longitude, latitude].\n    return new SDKLatLng(prediction.center[1], prediction.center[0]);\n  }\n  return null;\n};\n\nconst placeBounds = prediction => {\n  if (prediction) {\n    if (Array.isArray(prediction.bbox) && prediction.bbox.length === 4) {\n      // Bounds in Mapbox features are represented as [minX, minY, maxX, maxY]\n      return new SDKLatLngBounds(\n        new SDKLatLng(prediction.bbox[3], prediction.bbox[2]),\n        new SDKLatLng(prediction.bbox[1], prediction.bbox[0])\n      );\n    } else {\n      // If bounds are not available, generate them around the origin\n\n      // Resolve bounds distance based on place type\n      const placeType = Array.isArray(prediction.place_type) && prediction.place_type[0];\n\n      const distance =\n        (placeType && PLACE_TYPE_BOUNDS_DISTANCES[placeType]) || GENERATED_BOUNDS_DEFAULT_DISTANCE;\n\n      return locationBounds(placeOrigin(prediction), distance);\n    }\n  }\n  return null;\n};\n\nexport const GeocoderAttribution = () => null;\n\n/**\n * A forward geocoding (place name -> coordinates) implementation\n * using the Mapbox Geocoding API.\n */\nclass GeocoderMapbox {\n  getClient() {\n    const libLoaded = typeof window !== 'undefined' && window.mapboxgl && window.mapboxSdk;\n    if (!libLoaded) {\n      throw new Error('Mapbox libraries are required for GeocoderMapbox');\n    }\n    if (!this._client) {\n      this._client = window.mapboxSdk({\n        accessToken: window.mapboxgl.accessToken,\n      });\n    }\n    return this._client;\n  }\n\n  // Public API\n  //\n\n  /**\n   * Search places with the given name.\n   *\n   * @param {String} search query for place names\n   *\n   * @return {Promise<{ search: String, predictions: Array<Object>}>}\n   * results of the geocoding, should have the original search query\n   * and an array of predictions. The format of the predictions is\n   * only relevant for the `getPlaceDetails` function below.\n   */\n  getPlacePredictions(search) {\n    const limitCountriesMaybe = config.maps.search.countryLimit\n      ? { countries: config.maps.search.countryLimit }\n      : {};\n\n    return this.getClient()\n      .geocoding.forwardGeocode({\n        query: search,\n        limit: 5,\n        ...limitCountriesMaybe,\n        language: [config.locale],\n      })\n      .send()\n      .then(response => {\n        return {\n          search,\n          predictions: response.body.features,\n        };\n      });\n  }\n\n  /**\n   * Get the ID of the given prediction.\n   */\n  getPredictionId(prediction) {\n    return prediction.id;\n  }\n\n  /**\n   * Get the address text of the given prediction.\n   */\n  getPredictionAddress(prediction) {\n    if (prediction.predictionPlace) {\n      // default prediction defined above\n      return prediction.predictionPlace.address;\n    }\n    // prediction from Mapbox geocoding API\n    return prediction.place_name;\n  }\n\n  /**\n   * Fetch or read place details from the selected prediction.\n   *\n   * @param {Object} prediction selected prediction object\n   *\n   * @return {Promise<util.propTypes.place>} a place object\n   */\n  getPlaceDetails(prediction) {\n    if (this.getPredictionId(prediction) === CURRENT_LOCATION_ID) {\n      return userLocation().then(latlng => {\n        return {\n          address: '',\n          origin: latlng,\n          bounds: locationBounds(latlng, config.maps.search.currentLocationBoundsDistance),\n        };\n      });\n    }\n\n    if (prediction.predictionPlace) {\n      return Promise.resolve(prediction.predictionPlace);\n    }\n\n    return Promise.resolve({\n      address: this.getPredictionAddress(prediction),\n      origin: placeOrigin(prediction),\n      bounds: placeBounds(prediction),\n    });\n  }\n}\n\nexport default GeocoderMapbox;\n"]},"metadata":{},"sourceType":"module"}