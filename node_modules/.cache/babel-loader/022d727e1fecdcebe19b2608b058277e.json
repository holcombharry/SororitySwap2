{"ast":null,"code":"var _jsxFileName = \"/Users/harryholcomb/Desktop/React Native/GitHub/Sharetribe/ftw-product/src/containers/SearchPage/SearchMap/SearchMapWithMapbox.js\";\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport { arrayOf, func, node, number, shape, string } from 'prop-types';\nimport differenceBy from 'lodash/differenceBy';\nimport isEqual from 'lodash/isEqual';\nimport classNames from 'classnames';\nimport { types as sdkTypes } from '../../../util/sdkLoader';\nimport { parse } from '../../../util/urlHelpers';\nimport { propTypes } from '../../../util/types';\nimport { ensureListing } from '../../../util/data';\nimport { sdkBoundsToFixedCoordinates, hasSameSDKBounds } from '../../../util/maps';\nimport SearchMapPriceLabel from '../SearchMapPriceLabel/SearchMapPriceLabel';\nimport SearchMapInfoCard from '../SearchMapInfoCard/SearchMapInfoCard';\nimport SearchMapGroupLabel from '../SearchMapGroupLabel/SearchMapGroupLabel';\nimport { groupedByCoordinates, reducedToArray } from './SearchMap.helpers';\nimport css from './SearchMapWithMapbox.module.css';\nexport const LABEL_HANDLE = 'SearchMapLabel';\nexport const INFO_CARD_HANDLE = 'SearchMapInfoCard';\nexport const SOURCE_AUTOCOMPLETE = 'autocomplete';\nconst BOUNDS_FIXED_PRECISION = 8;\nconst {\n  LatLng: SDKLatLng,\n  LatLngBounds: SDKLatLngBounds\n} = sdkTypes;\n/**\n * Fit part of map (descriped with bounds) to visible map-viewport\n *\n * @param {Object} map - map that needs to be centered with given bounds\n * @param {SDK.LatLngBounds} bounds - the area that needs to be visible when map loads.\n */\n\nexport const fitMapToBounds = (map, bounds, options) => {\n  const {\n    padding = 0,\n    isAutocompleteSearch = false\n  } = options; // map bounds as string literal for google.maps\n\n  const mapBounds = sdkBoundsToMapboxBounds(bounds);\n  const paddingOptionMaybe = padding == null ? {\n    padding\n  } : {};\n  const eventData = isAutocompleteSearch ? {\n    searchSource: SOURCE_AUTOCOMPLETE\n  } : {}; // If bounds are given, use it (defaults to center & zoom).\n\n  if (map && mapBounds) {\n    map.fitBounds(mapBounds, { ...paddingOptionMaybe,\n      linear: true,\n      duration: 0\n    }, eventData);\n  }\n};\n/**\n * Convert Mapbox formatted LatLng object to Sharetribe SDK's LatLng coordinate format\n * Longitudes > 180 and < -180 are converted to the correct corresponding value\n * between -180 and 180.\n *\n * @param {LngLat} mapboxLngLat - Mapbox LngLat\n *\n * @return {SDKLatLng} - Converted latLng coordinate\n */\n\nexport const mapboxLngLatToSDKLatLng = lngLat => {\n  const mapboxLng = lngLat.lng; // For bounding boxes that overlap the antimeridian Mapbox sometimes gives\n  // longitude values outside -180 and 180 degrees.Those values are converted\n  // so that longitude is always between -180 and 180.\n\n  const lng = mapboxLng > 180 ? mapboxLng - 360 : mapboxLng < -180 ? mapboxLng + 360 : mapboxLng;\n  return new SDKLatLng(lngLat.lat, lng);\n};\n/**\n * Convert Mapbox formatted bounds object to Sharetribe SDK's bounds format\n *\n * @param {LngLatBounds} mapboxBounds - Mapbox LngLatBounds\n *\n * @return {SDKLatLngBounds} - Converted bounds\n */\n\nexport const mapboxBoundsToSDKBounds = mapboxBounds => {\n  if (!mapboxBounds) {\n    return null;\n  }\n\n  const ne = mapboxBounds.getNorthEast();\n  const sw = mapboxBounds.getSouthWest();\n  return new SDKLatLngBounds(mapboxLngLatToSDKLatLng(ne), mapboxLngLatToSDKLatLng(sw));\n};\n/**\n * Convert sdk bounds that overlap the antimeridian into values that can\n * be passed to Mapbox. This is achieved by converting the SW longitude into\n * a value less than -180 that flows over the antimeridian.\n *\n * @param {SDKLatLng} bounds - bounds passed to the map\n *\n * @return {LngLatBoundsLike} a bounding box that is compatible with Mapbox\n */\n\nconst sdkBoundsToMapboxBounds = bounds => {\n  if (!bounds) {\n    return null;\n  }\n\n  const {\n    ne,\n    sw\n  } = bounds; // if sw lng is > ne lng => the bounds overlap antimeridian\n  // => flip the nw lng to the negative side so that the value\n  // is less than -180\n\n  const swLng = sw.lng > ne.lng ? -360 + sw.lng : sw.lng;\n  return [[swLng, sw.lat], [ne.lng, ne.lat]];\n};\n/**\n * Return map bounds as SDKBounds\n *\n * @param {Mapbox} map - Mapbox map from where the bounds are asked\n *\n * @return {SDKLatLngBounds} - Converted bounds of given map\n */\n\n\nexport const getMapBounds = map => mapboxBoundsToSDKBounds(map.getBounds());\n/**\n * Return map center as SDKLatLng\n *\n * @param {Mapbox} map - Mapbox map from where the center is asked\n *\n * @return {SDKLatLng} - Converted center of given map\n */\n\nexport const getMapCenter = map => mapboxLngLatToSDKLatLng(map.getCenter());\n/**\n * Check if map library is loaded\n */\n\nexport const isMapsLibLoaded = () => typeof window !== 'undefined' && window.mapboxgl && window.mapboxgl;\n/**\n * Return price labels grouped by listing locations.\n * This is a helper function for SearchMapWithMapbox component.\n */\n\nconst priceLabelsInLocations = (listings, activeListingId, infoCardOpen, onListingClicked, mapComponentRefreshToken) => {\n  const listingArraysInLocations = reducedToArray(groupedByCoordinates(listings));\n  const priceLabels = listingArraysInLocations.reverse().map(listingArr => {\n    const isActive = activeListingId ? !!listingArr.find(l => activeListingId.uuid === l.id.uuid) : false; // If location contains only one listing, print price label\n\n    if (listingArr.length === 1) {\n      const listing = listingArr[0];\n      const infoCardOpenIds = Array.isArray(infoCardOpen) ? infoCardOpen.map(l => l.id.uuid) : infoCardOpen ? [infoCardOpen.id.uuid] : []; // if the listing is open, don't print price label\n\n      if (infoCardOpen != null && infoCardOpenIds.includes(listing.id.uuid)) {\n        return null;\n      } // Explicit type change to object literal for Google OverlayViews (geolocation is SDK type)\n\n\n      const {\n        geolocation\n      } = listing.attributes;\n      const key = listing.id.uuid;\n      return {\n        markerId: `price_${key}`,\n        location: geolocation,\n        type: 'price',\n        componentProps: {\n          key,\n          isActive,\n          className: LABEL_HANDLE,\n          listing,\n          onListingClicked,\n          mapComponentRefreshToken\n        }\n      };\n    } // Explicit type change to object literal for Google OverlayViews (geolocation is SDK type)\n\n\n    const firstListing = ensureListing(listingArr[0]);\n    const geolocation = firstListing.attributes.geolocation;\n    const key = listingArr[0].id.uuid;\n    return {\n      markerId: `group_${key}`,\n      location: geolocation,\n      type: 'group',\n      componentProps: {\n        key,\n        isActive,\n        className: LABEL_HANDLE,\n        listings: listingArr,\n        onListingClicked,\n        mapComponentRefreshToken\n      }\n    };\n  });\n  return priceLabels;\n};\n/**\n * Return info card. This is a helper function for SearchMapWithMapbox component.\n */\n\n\nconst infoCardComponent = (infoCardOpen, onListingInfoCardClicked, createURLToListing, mapComponentRefreshToken) => {\n  const listingsArray = Array.isArray(infoCardOpen) ? infoCardOpen : [infoCardOpen];\n\n  if (!infoCardOpen) {\n    return null;\n  }\n\n  const firstListing = ensureListing(listingsArray[0]);\n  const key = firstListing.id.uuid;\n  const geolocation = firstListing.attributes.geolocation;\n  return {\n    markerId: `infoCard_${key}`,\n    location: geolocation,\n    componentProps: {\n      key,\n      mapComponentRefreshToken,\n      className: INFO_CARD_HANDLE,\n      listings: listingsArray,\n      onListingInfoCardClicked,\n      createURLToListing\n    }\n  };\n};\n/**\n * SearchMap component using Mapbox as map provider\n */\n\n\nclass SearchMapWithMapbox extends Component {\n  constructor(props) {\n    super(props);\n    this.map = typeof window !== 'undefined' && window.mapboxMap ? window.mapboxMap : null;\n    this.currentMarkers = [];\n    this.currentInfoCard = null;\n    this.state = {\n      mapContainer: null,\n      isMapReady: false\n    };\n    this.viewportBounds = null;\n    this.onMount = this.onMount.bind(this);\n    this.onMoveend = this.onMoveend.bind(this);\n    this.initializeMap = this.initializeMap.bind(this);\n    this.handleDoubleClickOnInfoCard = this.handleDoubleClickOnInfoCard.bind(this);\n    this.handleMobilePinchZoom = this.handleMobilePinchZoom.bind(this);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!isEqual(prevProps.location, this.props.location)) {\n      // If no mapSearch url parameter is given, this is original location search\n      const {\n        mapSearch\n      } = parse(this.props.location.search, {\n        latlng: ['origin'],\n        latlngBounds: ['bounds']\n      });\n\n      if (!mapSearch) {\n        this.viewportBounds = null;\n      }\n    }\n\n    if (this.map) {\n      const currentBounds = getMapBounds(this.map); // Do not call fitMapToBounds if bounds are the same.\n      // Our bounds are viewport bounds, and fitBounds will try to add margins around those bounds\n      // that would result to zoom-loop (bound change -> fitmap -> bounds change -> ...)\n\n      if (!isEqual(this.props.bounds, currentBounds) && !this.viewportBounds) {\n        fitMapToBounds(this.map, this.props.bounds, {\n          padding: 0,\n          isAutocompleteSearch: true\n        });\n      }\n    }\n\n    if (!this.map && this.state.mapContainer) {\n      this.initializeMap();\n      /* Notify parent component that Mapbox map is loaded */\n\n      this.props.onMapLoad(this.map);\n    } else if (prevProps.mapComponentRefreshToken !== this.props.mapComponentRefreshToken) {\n      /* Notify parent component that Mapbox map is loaded */\n      this.props.onMapLoad(this.map);\n    }\n  }\n\n  componentWillUnmount() {\n    this.currentInfoCard.markerContainer.removeEventListener('dblclick', this.handleDoubleClickOnInfoCard);\n    document.removeEventListener('gesturestart', this.handleMobilePinchZoom, false);\n    document.removeEventListener('gesturechange', this.handleMobilePinchZoom, false);\n    document.removeEventListener('gestureend', this.handleMobilePinchZoom, false);\n  }\n\n  onMount(element) {\n    // This prevents pinch zoom to affect whole page on mobile Safari.\n    document.addEventListener('gesturestart', this.handleMobilePinchZoom, false);\n    document.addEventListener('gesturechange', this.handleMobilePinchZoom, false);\n    document.addEventListener('gestureend', this.handleMobilePinchZoom, false);\n    this.setState({\n      mapContainer: element\n    });\n  }\n\n  onMoveend(e) {\n    if (this.map) {\n      // If reusableMapHiddenHandle is given and parent element has that class,\n      // we don't listen moveend events.\n      // This fixes mobile Chrome bug that sends map events to invisible map components.\n      const isHiddenByReusableMap = this.props.reusableMapHiddenHandle && this.state.mapContainer.parentElement.classList.contains(this.props.reusableMapHiddenHandle);\n\n      if (!isHiddenByReusableMap) {\n        const viewportMapBounds = getMapBounds(this.map);\n        const viewportMapCenter = getMapCenter(this.map);\n        const viewportBounds = sdkBoundsToFixedCoordinates(viewportMapBounds, BOUNDS_FIXED_PRECISION); // ViewportBounds from (previous) rendering differ from viewportBounds currently set to map\n        // I.e. user has changed the map somehow: moved, panned, zoomed, resized\n\n        const viewportBoundsChanged = this.viewportBounds && !hasSameSDKBounds(this.viewportBounds, viewportBounds);\n        this.props.onMapMoveEnd(viewportBoundsChanged, {\n          viewportBounds,\n          viewportMapCenter\n        });\n        this.viewportBounds = viewportBounds;\n      }\n    }\n  }\n\n  initializeMap() {\n    const {\n      offsetHeight,\n      offsetWidth\n    } = this.state.mapContainer;\n    const hasDimensions = offsetHeight > 0 && offsetWidth > 0;\n\n    if (hasDimensions) {\n      this.map = new window.mapboxgl.Map({\n        container: this.state.mapContainer,\n        style: 'mapbox://styles/mapbox/streets-v10',\n        scrollZoom: false\n      });\n      window.mapboxMap = this.map;\n      var nav = new window.mapboxgl.NavigationControl({\n        showCompass: false\n      });\n      this.map.addControl(nav, 'top-left');\n      this.map.on('moveend', this.onMoveend); // Introduce rerendering after map is ready (to include labels),\n      // but keep the map out of state life cycle.\n\n      this.setState({\n        isMapReady: true\n      });\n    }\n  }\n\n  handleMobilePinchZoom(e) {\n    e.preventDefault(); // A hack to prevent pinch zoom gesture in mobile Safari\n    // Otherwise, pinch zoom would zoom both map and the document.\n\n    document.body.style.zoom = 0.99;\n  }\n\n  handleDoubleClickOnInfoCard(e) {\n    e.stopPropagation();\n  }\n\n  render() {\n    const {\n      id,\n      className,\n      listings,\n      activeListingId,\n      infoCardOpen,\n      onListingClicked,\n      onListingInfoCardClicked,\n      createURLToListing,\n      mapComponentRefreshToken\n    } = this.props;\n\n    if (this.map) {\n      // Create markers out of price labels and grouped labels\n      const labels = priceLabelsInLocations(listings, activeListingId, infoCardOpen, onListingClicked, mapComponentRefreshToken); // If map has moved or info card opened, unnecessary markers need to be removed\n\n      const removableMarkers = differenceBy(this.currentMarkers, labels, 'markerId');\n      removableMarkers.forEach(rm => rm.marker.remove()); // Helper function to create markers to given container\n\n      const createMarker = (data, markerContainer) => new window.mapboxgl.Marker(markerContainer, {\n        anchor: 'bottom'\n      }).setLngLat([data.location.lng, data.location.lat]).addTo(this.map); // SearchMapPriceLabel and SearchMapGroupLabel:\n      // create a new marker or use existing one if markerId is among previously rendered markers\n\n\n      this.currentMarkers = labels.filter(v => v != null).map(m => {\n        const existingMarkerId = this.currentMarkers.findIndex(marker => m.markerId === marker.markerId && marker.marker);\n\n        if (existingMarkerId >= 0) {\n          const {\n            marker,\n            markerContainer,\n            ...rest\n          } = this.currentMarkers[existingMarkerId];\n          return { ...rest,\n            ...m,\n            markerContainer,\n            marker\n          };\n        } else {\n          const markerContainer = document.createElement('div');\n          markerContainer.setAttribute('id', m.markerId);\n          markerContainer.classList.add(css.labelContainer);\n          const marker = createMarker(m, markerContainer);\n          return { ...m,\n            markerContainer,\n            marker\n          };\n        }\n      });\n      /* Create marker for SearchMapInfoCard component */\n\n      if (infoCardOpen) {\n        const infoCard = infoCardComponent(infoCardOpen, onListingInfoCardClicked, createURLToListing, mapComponentRefreshToken); // marker container and its styles\n\n        const infoCardContainer = document.createElement('div');\n        infoCardContainer.setAttribute('id', infoCard.markerId);\n        infoCardContainer.classList.add(css.infoCardContainer);\n        infoCardContainer.addEventListener('dblclick', this.handleDoubleClickOnInfoCard, false);\n        this.currentInfoCard = { ...infoCard,\n          markerContainer: infoCardContainer,\n          marker: infoCard ? createMarker(infoCard, infoCardContainer) : null\n        };\n      } else {\n        if (this.currentInfoCard) {\n          this.currentInfoCard.markerContainer.removeEventListener('dblclick', this.handleDoubleClickOnInfoCard);\n        }\n\n        this.currentInfoCard = null;\n      }\n    }\n\n    return /*#__PURE__*/React.createElement(\"div\", {\n      id: id,\n      ref: this.onMount,\n      className: classNames(className, css.fullArea),\n      onClick: this.props.onClick,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 456,\n        columnNumber: 7\n      }\n    }, this.currentMarkers.map(m => {\n      // Remove existing activeLabel classes and add it only to the correct container\n      m.markerContainer.classList.remove(css.activeLabel);\n\n      if (activeListingId && activeListingId.uuid === m.componentProps.key) {\n        m.markerContainer.classList.add(css.activeLabel);\n      }\n\n      const isMapReadyForMarkers = this.map && m.markerContainer; // DOM node that should be used as portal's root\n\n      const portalDOMContainer = isMapReadyForMarkers ? document.getElementById(m.markerContainer.id) : null; // Create component portals for correct marker containers\n\n      if (isMapReadyForMarkers && m.type === 'price') {\n        return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(SearchMapPriceLabel, Object.assign({}, m.componentProps, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 478,\n            columnNumber: 15\n          }\n        })), portalDOMContainer);\n      } else if (isMapReadyForMarkers && m.type === 'group') {\n        return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(SearchMapGroupLabel, Object.assign({}, m.componentProps, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 483,\n            columnNumber: 15\n          }\n        })), portalDOMContainer);\n      }\n\n      return null;\n    }), this.state.mapContainer && this.currentInfoCard ? /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(SearchMapInfoCard, Object.assign({}, this.currentInfoCard.componentProps, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 491,\n        columnNumber: 15\n      }\n    })), this.currentInfoCard.markerContainer) : null);\n  }\n\n}\n\nSearchMapWithMapbox.defaultProps = {\n  id: 'map',\n  center: null,\n  priceLabels: [],\n  infoCard: null,\n  zoom: 11,\n  reusableMapHiddenHandle: null\n};\nSearchMapWithMapbox.propTypes = {\n  id: string,\n  center: propTypes.latlng,\n  location: shape({\n    search: string.isRequired\n  }).isRequired,\n  priceLabels: arrayOf(node),\n  infoCard: node,\n  onClick: func.isRequired,\n  onMapMoveEnd: func.isRequired,\n  onMapLoad: func.isRequired,\n  zoom: number,\n  reusableMapHiddenHandle: string\n};\nexport default SearchMapWithMapbox;","map":{"version":3,"sources":["/Users/harryholcomb/Desktop/React Native/GitHub/Sharetribe/ftw-product/src/containers/SearchPage/SearchMap/SearchMapWithMapbox.js"],"names":["React","Component","ReactDOM","arrayOf","func","node","number","shape","string","differenceBy","isEqual","classNames","types","sdkTypes","parse","propTypes","ensureListing","sdkBoundsToFixedCoordinates","hasSameSDKBounds","SearchMapPriceLabel","SearchMapInfoCard","SearchMapGroupLabel","groupedByCoordinates","reducedToArray","css","LABEL_HANDLE","INFO_CARD_HANDLE","SOURCE_AUTOCOMPLETE","BOUNDS_FIXED_PRECISION","LatLng","SDKLatLng","LatLngBounds","SDKLatLngBounds","fitMapToBounds","map","bounds","options","padding","isAutocompleteSearch","mapBounds","sdkBoundsToMapboxBounds","paddingOptionMaybe","eventData","searchSource","fitBounds","linear","duration","mapboxLngLatToSDKLatLng","lngLat","mapboxLng","lng","lat","mapboxBoundsToSDKBounds","mapboxBounds","ne","getNorthEast","sw","getSouthWest","swLng","getMapBounds","getBounds","getMapCenter","getCenter","isMapsLibLoaded","window","mapboxgl","priceLabelsInLocations","listings","activeListingId","infoCardOpen","onListingClicked","mapComponentRefreshToken","listingArraysInLocations","priceLabels","reverse","listingArr","isActive","find","l","uuid","id","length","listing","infoCardOpenIds","Array","isArray","includes","geolocation","attributes","key","markerId","location","type","componentProps","className","firstListing","infoCardComponent","onListingInfoCardClicked","createURLToListing","listingsArray","SearchMapWithMapbox","constructor","props","mapboxMap","currentMarkers","currentInfoCard","state","mapContainer","isMapReady","viewportBounds","onMount","bind","onMoveend","initializeMap","handleDoubleClickOnInfoCard","handleMobilePinchZoom","componentDidUpdate","prevProps","mapSearch","search","latlng","latlngBounds","currentBounds","onMapLoad","componentWillUnmount","markerContainer","removeEventListener","document","element","addEventListener","setState","e","isHiddenByReusableMap","reusableMapHiddenHandle","parentElement","classList","contains","viewportMapBounds","viewportMapCenter","viewportBoundsChanged","onMapMoveEnd","offsetHeight","offsetWidth","hasDimensions","Map","container","style","scrollZoom","nav","NavigationControl","showCompass","addControl","on","preventDefault","body","zoom","stopPropagation","render","labels","removableMarkers","forEach","rm","marker","remove","createMarker","data","Marker","anchor","setLngLat","addTo","filter","v","m","existingMarkerId","findIndex","rest","createElement","setAttribute","add","labelContainer","infoCard","infoCardContainer","fullArea","onClick","activeLabel","isMapReadyForMarkers","portalDOMContainer","getElementById","createPortal","defaultProps","center","isRequired"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport { arrayOf, func, node, number, shape, string } from 'prop-types';\nimport differenceBy from 'lodash/differenceBy';\nimport isEqual from 'lodash/isEqual';\nimport classNames from 'classnames';\n\nimport { types as sdkTypes } from '../../../util/sdkLoader';\nimport { parse } from '../../../util/urlHelpers';\nimport { propTypes } from '../../../util/types';\nimport { ensureListing } from '../../../util/data';\nimport { sdkBoundsToFixedCoordinates, hasSameSDKBounds } from '../../../util/maps';\n\nimport SearchMapPriceLabel from '../SearchMapPriceLabel/SearchMapPriceLabel';\nimport SearchMapInfoCard from '../SearchMapInfoCard/SearchMapInfoCard';\nimport SearchMapGroupLabel from '../SearchMapGroupLabel/SearchMapGroupLabel';\nimport { groupedByCoordinates, reducedToArray } from './SearchMap.helpers';\nimport css from './SearchMapWithMapbox.module.css';\n\nexport const LABEL_HANDLE = 'SearchMapLabel';\nexport const INFO_CARD_HANDLE = 'SearchMapInfoCard';\nexport const SOURCE_AUTOCOMPLETE = 'autocomplete';\nconst BOUNDS_FIXED_PRECISION = 8;\n\nconst { LatLng: SDKLatLng, LatLngBounds: SDKLatLngBounds } = sdkTypes;\n\n/**\n * Fit part of map (descriped with bounds) to visible map-viewport\n *\n * @param {Object} map - map that needs to be centered with given bounds\n * @param {SDK.LatLngBounds} bounds - the area that needs to be visible when map loads.\n */\nexport const fitMapToBounds = (map, bounds, options) => {\n  const { padding = 0, isAutocompleteSearch = false } = options;\n\n  // map bounds as string literal for google.maps\n  const mapBounds = sdkBoundsToMapboxBounds(bounds);\n  const paddingOptionMaybe = padding == null ? { padding } : {};\n  const eventData = isAutocompleteSearch ? { searchSource: SOURCE_AUTOCOMPLETE } : {};\n\n  // If bounds are given, use it (defaults to center & zoom).\n  if (map && mapBounds) {\n    map.fitBounds(mapBounds, { ...paddingOptionMaybe, linear: true, duration: 0 }, eventData);\n  }\n};\n\n/**\n * Convert Mapbox formatted LatLng object to Sharetribe SDK's LatLng coordinate format\n * Longitudes > 180 and < -180 are converted to the correct corresponding value\n * between -180 and 180.\n *\n * @param {LngLat} mapboxLngLat - Mapbox LngLat\n *\n * @return {SDKLatLng} - Converted latLng coordinate\n */\nexport const mapboxLngLatToSDKLatLng = lngLat => {\n  const mapboxLng = lngLat.lng;\n\n  // For bounding boxes that overlap the antimeridian Mapbox sometimes gives\n  // longitude values outside -180 and 180 degrees.Those values are converted\n  // so that longitude is always between -180 and 180.\n  const lng = mapboxLng > 180 ? mapboxLng - 360 : mapboxLng < -180 ? mapboxLng + 360 : mapboxLng;\n\n  return new SDKLatLng(lngLat.lat, lng);\n};\n\n/**\n * Convert Mapbox formatted bounds object to Sharetribe SDK's bounds format\n *\n * @param {LngLatBounds} mapboxBounds - Mapbox LngLatBounds\n *\n * @return {SDKLatLngBounds} - Converted bounds\n */\nexport const mapboxBoundsToSDKBounds = mapboxBounds => {\n  if (!mapboxBounds) {\n    return null;\n  }\n\n  const ne = mapboxBounds.getNorthEast();\n  const sw = mapboxBounds.getSouthWest();\n  return new SDKLatLngBounds(mapboxLngLatToSDKLatLng(ne), mapboxLngLatToSDKLatLng(sw));\n};\n\n/**\n * Convert sdk bounds that overlap the antimeridian into values that can\n * be passed to Mapbox. This is achieved by converting the SW longitude into\n * a value less than -180 that flows over the antimeridian.\n *\n * @param {SDKLatLng} bounds - bounds passed to the map\n *\n * @return {LngLatBoundsLike} a bounding box that is compatible with Mapbox\n */\nconst sdkBoundsToMapboxBounds = bounds => {\n  if (!bounds) {\n    return null;\n  }\n  const { ne, sw } = bounds;\n\n  // if sw lng is > ne lng => the bounds overlap antimeridian\n  // => flip the nw lng to the negative side so that the value\n  // is less than -180\n  const swLng = sw.lng > ne.lng ? -360 + sw.lng : sw.lng;\n\n  return [[swLng, sw.lat], [ne.lng, ne.lat]];\n};\n\n/**\n * Return map bounds as SDKBounds\n *\n * @param {Mapbox} map - Mapbox map from where the bounds are asked\n *\n * @return {SDKLatLngBounds} - Converted bounds of given map\n */\nexport const getMapBounds = map => mapboxBoundsToSDKBounds(map.getBounds());\n\n/**\n * Return map center as SDKLatLng\n *\n * @param {Mapbox} map - Mapbox map from where the center is asked\n *\n * @return {SDKLatLng} - Converted center of given map\n */\nexport const getMapCenter = map => mapboxLngLatToSDKLatLng(map.getCenter());\n\n/**\n * Check if map library is loaded\n */\nexport const isMapsLibLoaded = () =>\n  typeof window !== 'undefined' && window.mapboxgl && window.mapboxgl;\n\n/**\n * Return price labels grouped by listing locations.\n * This is a helper function for SearchMapWithMapbox component.\n */\nconst priceLabelsInLocations = (\n  listings,\n  activeListingId,\n  infoCardOpen,\n  onListingClicked,\n  mapComponentRefreshToken\n) => {\n  const listingArraysInLocations = reducedToArray(groupedByCoordinates(listings));\n  const priceLabels = listingArraysInLocations.reverse().map(listingArr => {\n    const isActive = activeListingId\n      ? !!listingArr.find(l => activeListingId.uuid === l.id.uuid)\n      : false;\n\n    // If location contains only one listing, print price label\n    if (listingArr.length === 1) {\n      const listing = listingArr[0];\n      const infoCardOpenIds = Array.isArray(infoCardOpen)\n        ? infoCardOpen.map(l => l.id.uuid)\n        : infoCardOpen\n        ? [infoCardOpen.id.uuid]\n        : [];\n\n      // if the listing is open, don't print price label\n      if (infoCardOpen != null && infoCardOpenIds.includes(listing.id.uuid)) {\n        return null;\n      }\n\n      // Explicit type change to object literal for Google OverlayViews (geolocation is SDK type)\n      const { geolocation } = listing.attributes;\n\n      const key = listing.id.uuid;\n      return {\n        markerId: `price_${key}`,\n        location: geolocation,\n        type: 'price',\n        componentProps: {\n          key,\n          isActive,\n          className: LABEL_HANDLE,\n          listing,\n          onListingClicked,\n          mapComponentRefreshToken,\n        },\n      };\n    }\n\n    // Explicit type change to object literal for Google OverlayViews (geolocation is SDK type)\n    const firstListing = ensureListing(listingArr[0]);\n    const geolocation = firstListing.attributes.geolocation;\n\n    const key = listingArr[0].id.uuid;\n    return {\n      markerId: `group_${key}`,\n      location: geolocation,\n      type: 'group',\n      componentProps: {\n        key,\n        isActive,\n        className: LABEL_HANDLE,\n        listings: listingArr,\n        onListingClicked,\n        mapComponentRefreshToken,\n      },\n    };\n  });\n  return priceLabels;\n};\n\n/**\n * Return info card. This is a helper function for SearchMapWithMapbox component.\n */\nconst infoCardComponent = (\n  infoCardOpen,\n  onListingInfoCardClicked,\n  createURLToListing,\n  mapComponentRefreshToken\n) => {\n  const listingsArray = Array.isArray(infoCardOpen) ? infoCardOpen : [infoCardOpen];\n\n  if (!infoCardOpen) {\n    return null;\n  }\n\n  const firstListing = ensureListing(listingsArray[0]);\n  const key = firstListing.id.uuid;\n  const geolocation = firstListing.attributes.geolocation;\n\n  return {\n    markerId: `infoCard_${key}`,\n    location: geolocation,\n    componentProps: {\n      key,\n      mapComponentRefreshToken,\n      className: INFO_CARD_HANDLE,\n      listings: listingsArray,\n      onListingInfoCardClicked,\n      createURLToListing,\n    },\n  };\n};\n\n/**\n * SearchMap component using Mapbox as map provider\n */\nclass SearchMapWithMapbox extends Component {\n  constructor(props) {\n    super(props);\n    this.map = typeof window !== 'undefined' && window.mapboxMap ? window.mapboxMap : null;\n    this.currentMarkers = [];\n    this.currentInfoCard = null;\n    this.state = { mapContainer: null, isMapReady: false };\n    this.viewportBounds = null;\n\n    this.onMount = this.onMount.bind(this);\n    this.onMoveend = this.onMoveend.bind(this);\n    this.initializeMap = this.initializeMap.bind(this);\n    this.handleDoubleClickOnInfoCard = this.handleDoubleClickOnInfoCard.bind(this);\n    this.handleMobilePinchZoom = this.handleMobilePinchZoom.bind(this);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!isEqual(prevProps.location, this.props.location)) {\n      // If no mapSearch url parameter is given, this is original location search\n      const { mapSearch } = parse(this.props.location.search, {\n        latlng: ['origin'],\n        latlngBounds: ['bounds'],\n      });\n      if (!mapSearch) {\n        this.viewportBounds = null;\n      }\n    }\n\n    if (this.map) {\n      const currentBounds = getMapBounds(this.map);\n\n      // Do not call fitMapToBounds if bounds are the same.\n      // Our bounds are viewport bounds, and fitBounds will try to add margins around those bounds\n      // that would result to zoom-loop (bound change -> fitmap -> bounds change -> ...)\n      if (!isEqual(this.props.bounds, currentBounds) && !this.viewportBounds) {\n        fitMapToBounds(this.map, this.props.bounds, { padding: 0, isAutocompleteSearch: true });\n      }\n    }\n\n    if (!this.map && this.state.mapContainer) {\n      this.initializeMap();\n\n      /* Notify parent component that Mapbox map is loaded */\n      this.props.onMapLoad(this.map);\n    } else if (prevProps.mapComponentRefreshToken !== this.props.mapComponentRefreshToken) {\n      /* Notify parent component that Mapbox map is loaded */\n      this.props.onMapLoad(this.map);\n    }\n  }\n\n  componentWillUnmount() {\n    this.currentInfoCard.markerContainer.removeEventListener(\n      'dblclick',\n      this.handleDoubleClickOnInfoCard\n    );\n    document.removeEventListener('gesturestart', this.handleMobilePinchZoom, false);\n    document.removeEventListener('gesturechange', this.handleMobilePinchZoom, false);\n    document.removeEventListener('gestureend', this.handleMobilePinchZoom, false);\n  }\n\n  onMount(element) {\n    // This prevents pinch zoom to affect whole page on mobile Safari.\n    document.addEventListener('gesturestart', this.handleMobilePinchZoom, false);\n    document.addEventListener('gesturechange', this.handleMobilePinchZoom, false);\n    document.addEventListener('gestureend', this.handleMobilePinchZoom, false);\n\n    this.setState({ mapContainer: element });\n  }\n\n  onMoveend(e) {\n    if (this.map) {\n      // If reusableMapHiddenHandle is given and parent element has that class,\n      // we don't listen moveend events.\n      // This fixes mobile Chrome bug that sends map events to invisible map components.\n      const isHiddenByReusableMap =\n        this.props.reusableMapHiddenHandle &&\n        this.state.mapContainer.parentElement.classList.contains(\n          this.props.reusableMapHiddenHandle\n        );\n      if (!isHiddenByReusableMap) {\n        const viewportMapBounds = getMapBounds(this.map);\n        const viewportMapCenter = getMapCenter(this.map);\n        const viewportBounds = sdkBoundsToFixedCoordinates(\n          viewportMapBounds,\n          BOUNDS_FIXED_PRECISION\n        );\n\n        // ViewportBounds from (previous) rendering differ from viewportBounds currently set to map\n        // I.e. user has changed the map somehow: moved, panned, zoomed, resized\n        const viewportBoundsChanged =\n          this.viewportBounds && !hasSameSDKBounds(this.viewportBounds, viewportBounds);\n\n        this.props.onMapMoveEnd(viewportBoundsChanged, { viewportBounds, viewportMapCenter });\n        this.viewportBounds = viewportBounds;\n      }\n    }\n  }\n\n  initializeMap() {\n    const { offsetHeight, offsetWidth } = this.state.mapContainer;\n    const hasDimensions = offsetHeight > 0 && offsetWidth > 0;\n    if (hasDimensions) {\n      this.map = new window.mapboxgl.Map({\n        container: this.state.mapContainer,\n        style: 'mapbox://styles/mapbox/streets-v10',\n        scrollZoom: false,\n      });\n      window.mapboxMap = this.map;\n\n      var nav = new window.mapboxgl.NavigationControl({ showCompass: false });\n      this.map.addControl(nav, 'top-left');\n\n      this.map.on('moveend', this.onMoveend);\n\n      // Introduce rerendering after map is ready (to include labels),\n      // but keep the map out of state life cycle.\n      this.setState({ isMapReady: true });\n    }\n  }\n\n  handleMobilePinchZoom(e) {\n    e.preventDefault();\n    // A hack to prevent pinch zoom gesture in mobile Safari\n    // Otherwise, pinch zoom would zoom both map and the document.\n    document.body.style.zoom = 0.99;\n  }\n\n  handleDoubleClickOnInfoCard(e) {\n    e.stopPropagation();\n  }\n\n  render() {\n    const {\n      id,\n      className,\n      listings,\n      activeListingId,\n      infoCardOpen,\n      onListingClicked,\n      onListingInfoCardClicked,\n      createURLToListing,\n      mapComponentRefreshToken,\n    } = this.props;\n\n    if (this.map) {\n      // Create markers out of price labels and grouped labels\n      const labels = priceLabelsInLocations(\n        listings,\n        activeListingId,\n        infoCardOpen,\n        onListingClicked,\n        mapComponentRefreshToken\n      );\n\n      // If map has moved or info card opened, unnecessary markers need to be removed\n      const removableMarkers = differenceBy(this.currentMarkers, labels, 'markerId');\n      removableMarkers.forEach(rm => rm.marker.remove());\n\n      // Helper function to create markers to given container\n      const createMarker = (data, markerContainer) =>\n        new window.mapboxgl.Marker(markerContainer, { anchor: 'bottom' })\n          .setLngLat([data.location.lng, data.location.lat])\n          .addTo(this.map);\n\n      // SearchMapPriceLabel and SearchMapGroupLabel:\n      // create a new marker or use existing one if markerId is among previously rendered markers\n      this.currentMarkers = labels\n        .filter(v => v != null)\n        .map(m => {\n          const existingMarkerId = this.currentMarkers.findIndex(\n            marker => m.markerId === marker.markerId && marker.marker\n          );\n\n          if (existingMarkerId >= 0) {\n            const { marker, markerContainer, ...rest } = this.currentMarkers[existingMarkerId];\n            return { ...rest, ...m, markerContainer, marker };\n          } else {\n            const markerContainer = document.createElement('div');\n            markerContainer.setAttribute('id', m.markerId);\n            markerContainer.classList.add(css.labelContainer);\n            const marker = createMarker(m, markerContainer);\n            return { ...m, markerContainer, marker };\n          }\n        });\n\n      /* Create marker for SearchMapInfoCard component */\n      if (infoCardOpen) {\n        const infoCard = infoCardComponent(\n          infoCardOpen,\n          onListingInfoCardClicked,\n          createURLToListing,\n          mapComponentRefreshToken\n        );\n\n        // marker container and its styles\n        const infoCardContainer = document.createElement('div');\n        infoCardContainer.setAttribute('id', infoCard.markerId);\n        infoCardContainer.classList.add(css.infoCardContainer);\n        infoCardContainer.addEventListener('dblclick', this.handleDoubleClickOnInfoCard, false);\n\n        this.currentInfoCard = {\n          ...infoCard,\n          markerContainer: infoCardContainer,\n          marker: infoCard ? createMarker(infoCard, infoCardContainer) : null,\n        };\n      } else {\n        if (this.currentInfoCard) {\n          this.currentInfoCard.markerContainer.removeEventListener(\n            'dblclick',\n            this.handleDoubleClickOnInfoCard\n          );\n        }\n        this.currentInfoCard = null;\n      }\n    }\n\n    return (\n      <div\n        id={id}\n        ref={this.onMount}\n        className={classNames(className, css.fullArea)}\n        onClick={this.props.onClick}\n      >\n        {this.currentMarkers.map(m => {\n          // Remove existing activeLabel classes and add it only to the correct container\n          m.markerContainer.classList.remove(css.activeLabel);\n          if (activeListingId && activeListingId.uuid === m.componentProps.key) {\n            m.markerContainer.classList.add(css.activeLabel);\n          }\n\n          const isMapReadyForMarkers = this.map && m.markerContainer;\n          // DOM node that should be used as portal's root\n          const portalDOMContainer = isMapReadyForMarkers\n            ? document.getElementById(m.markerContainer.id)\n            : null;\n\n          // Create component portals for correct marker containers\n          if (isMapReadyForMarkers && m.type === 'price') {\n            return ReactDOM.createPortal(\n              <SearchMapPriceLabel {...m.componentProps} />,\n              portalDOMContainer\n            );\n          } else if (isMapReadyForMarkers && m.type === 'group') {\n            return ReactDOM.createPortal(\n              <SearchMapGroupLabel {...m.componentProps} />,\n              portalDOMContainer\n            );\n          }\n          return null;\n        })}\n        {this.state.mapContainer && this.currentInfoCard\n          ? ReactDOM.createPortal(\n              <SearchMapInfoCard {...this.currentInfoCard.componentProps} />,\n              this.currentInfoCard.markerContainer\n            )\n          : null}\n      </div>\n    );\n  }\n}\n\nSearchMapWithMapbox.defaultProps = {\n  id: 'map',\n  center: null,\n  priceLabels: [],\n  infoCard: null,\n  zoom: 11,\n  reusableMapHiddenHandle: null,\n};\n\nSearchMapWithMapbox.propTypes = {\n  id: string,\n  center: propTypes.latlng,\n  location: shape({\n    search: string.isRequired,\n  }).isRequired,\n  priceLabels: arrayOf(node),\n  infoCard: node,\n  onClick: func.isRequired,\n  onMapMoveEnd: func.isRequired,\n  onMapLoad: func.isRequired,\n  zoom: number,\n  reusableMapHiddenHandle: string,\n};\n\nexport default SearchMapWithMapbox;\n"]},"metadata":{},"sourceType":"module"}