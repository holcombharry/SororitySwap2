{"ast":null,"code":"import moment from 'moment-timezone/builds/moment-timezone-with-data-10-year-range.min';\n/**\n * Input names for the DateRangePicker from react-dates.\n */\n\nexport const START_DATE = 'startDate';\nexport const END_DATE = 'endDate';\n/**\n * Check if the browser's DateTimeFormat API supports time zones.\n *\n * @returns {Boolean} true if the browser returns current time zone.\n */\n\nexport const isTimeZoneSupported = () => {\n  if (!Intl || typeof Intl === 'undefined' || typeof Intl.DateTimeFormat === 'undefined') {\n    return false;\n  }\n\n  const dtf = new Intl.DateTimeFormat();\n\n  if (typeof dtf === 'undefined' || typeof dtf.resolvedOptions === 'undefined') {\n    return false;\n  }\n\n  return !!dtf.resolvedOptions().timeZone;\n};\n/**\n * Check if the given time zone key is valid.\n *\n * @param {String} timeZone time zone id, see:\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n *\n * @returns {Boolean} true if the browser recognizes the key.\n */\n\nexport const isValidTimeZone = timeZone => {\n  try {\n    new Intl.DateTimeFormat('en-US', {\n      timeZone\n    }).format();\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n * Check that the given parameter is a Date object.\n *\n * @param {Date} object that should be a Date.\n *\n * @returns {boolean} true if given parameter is a Date object.\n */\n\nexport const isDate = d => d && Object.prototype.toString.call(d) === '[object Date]' && !Number.isNaN(d.getTime());\n/**\n * Check if the given parameters represent the same Date value (timestamps are compared)\n *\n * @param {Date} first param that should be a Date and it should have same timestamp as second param.\n * @param {Date} second param that should be a Date and it should have same timestamp as second param.\n *\n * @returns {boolean} true if given parameters have the same timestamp.\n */\n\nexport const isSameDate = (a, b) => a && isDate(a) && b && isDate(b) && a.getTime() === b.getTime();\n/**\n * Compare is dateA is after dateB\n *\n * @param {Date} dateA date instance\n * @param {Date} dateB date instance\n *\n * @returns {Date} true if dateA is after dateB\n */\n\nexport const isAfterDate = (dateA, dateB) => {\n  return moment(dateA).isAfter(moment(dateB));\n}; ////////////////////////////////////////////////////////////////////\n// Manipulate time: time-of-day between different time zones etc. //\n////////////////////////////////////////////////////////////////////\n\n/**\n * Returns a new date, which indicates the same time of day in a given time zone\n * as given date is in local time zone\n *\n * @param {Date} date\n * @param {String} timeZone\n *\n * @returns {Date} date in given time zone\n */\n\nexport const timeOfDayFromLocalToTimeZone = (date, timeZone) => {\n  return moment.tz(moment(date).format('YYYY-MM-DD HH:mm:ss'), timeZone).toDate();\n};\n/**\n * Returns a new date, which indicates the same time of day in a local time zone\n * as given date is in specified time zone\n *\n * @param {Date} date\n * @param {String} timeZone\n *\n * @returns {Date} date in given time zone\n */\n\nexport const timeOfDayFromTimeZoneToLocal = (date, timeZone) => {\n  return moment(moment(date).tz(timeZone).format('YYYY-MM-DD HH:mm:ss')).toDate();\n};\n/**\n * Get start of time unit (e.g. start of day)\n *\n * @param {Date} date date instance to be converted\n * @param {String} unit time-unit (e.g. \"day\")\n * @param {String} timeZone time zone id\n *\n * @returns {Date} date object converted to the start of given unit\n */\n\nexport const getStartOf = (date, unit, timeZone) => {\n  const m = timeZone ? moment(date).clone().tz(timeZone) : moment(date).clone();\n  return m.startOf(unit).toDate();\n};\n/**\n * Adds time-units to the date\n *\n * @param {Date} date date to be manipulated\n * @param {int} offset offset of time-units (e.g. \"3\" days)\n * @param {String} unit time-unit (e.g. \"days\")\n * @param {String} timeZone time zone name\n *\n * @returns {Date} date with given offset added\n */\n\nexport const addTime = (date, offset, unit, timeZone) => {\n  const m = timeZone ? moment(date).clone().tz(timeZone) : moment(date).clone();\n  return m.add(offset, unit).toDate();\n};\n/**\n * Subtract time-units from the date\n *\n * @param {Date} date date to be manipulated\n * @param {int} offset offset of time-units (e.g. \"3\" days)\n * @param {String} unit time-unit (e.g. \"days\")\n * @param {String} timeZone time zone name\n *\n * @returns {Date} date with given offset subtracted\n */\n\nexport const subtractTime = (date, offset, unit, timeZone) => {\n  const m = timeZone ? moment(date).clone().tz(timeZone) : moment(date).clone();\n  return m.subtract(offset, unit).toDate();\n}; ///////////////\n// Durations //\n///////////////\n\n/**\n * Calculate the number of days between the given dates.\n * This uses moment#diff and, therefore, it just checks,\n * if there are 1000x60x60x24 milliseconds between date objects.\n *\n * Note: This should not be used for checking if the local date has\n *       changed between \"2021-04-07 23:00\" and \"2021-04-08 05:00\".\n *\n * @param {Date} startDate start of the time period\n * @param {Date} endDate end of the time period. NOTE: with daily\n * bookings, it is expected that this date is the exclusive end date,\n * i.e. the last day of the booking is the previous date of this end\n * date.\n *\n * @throws Will throw if the end date is before the start date\n * @returns {Number} number of days between the given dates\n */\n\nexport const daysBetween = (startDate, endDate) => {\n  const days = moment(endDate).diff(startDate, 'days');\n\n  if (days < 0) {\n    throw new Error('End date cannot be before start date');\n  }\n\n  return days;\n};\n/**\n * Count the number of minutes between the given Date objects.\n *\n * @param {Date} startDate start of the time period\n * @param {Date} endDate end of the time period.\n *\n * @returns {Number} number of minutes between the given Date objects\n */\n\nexport const minutesBetween = (startDate, endDate) => {\n  const minutes = moment(endDate).diff(startDate, 'minutes');\n  return minutes;\n};\n/**\n * Calculate the difference between the given dates\n *\n * @param {Date} startDate start of the time period\n * @param {Date} endDate end of the time period.\n * @param {String} unit time unit. E.g. 'years'.\n * @param {String} useFloat Should return floating point numbers?\n *\n * @returns {Number} time difference between the given Date objects using given unit\n */\n\nexport const diffInTime = (startDate, endDate, unit, useFloat = false) => {\n  return moment(startDate).diff(endDate, unit, useFloat);\n}; ////////////////////////////\n// Parsing and formatting //\n////////////////////////////\n\nconst getTimeZoneMaybe = timeZone => {\n  if (timeZone) {\n    if (!isTimeZoneSupported()) {\n      throw new Error(`Your browser doesn't support time zones.`);\n    }\n\n    if (!isValidTimeZone(timeZone)) {\n      throw new Error(`Given time zone key (${timeZone}) is not valid.`);\n    }\n\n    return {\n      timeZone\n    };\n  }\n\n  return {};\n};\n/**\n * Format the given date. Printed string depends on how close the date is the current day.\n * E.g. \"Today, 9:10 PM\", \"Sun 6:02 PM\", \"Jul 20, 6:02 PM\", \"Jul 20 2020, 6:02 PM\"\n *\n * @param {Date} date Date to be formatted\n * @param {Object} intl Intl object from react-intl\n * @param {String} todayString translation for the current day\n * @param {Object} [opts] options. Can be used to pass in timeZone. It should represent IANA time zone key.\n *\n * @returns {String} formatted date\n */\n\n\nexport const formatDateWithProximity = (date, intl, todayString, opts = {}) => {\n  const paramsValid = intl && date instanceof Date && typeof todayString === 'string';\n\n  if (!paramsValid) {\n    throw new Error(`Invalid params for formatDate: (${date}, ${intl}, ${todayString})`);\n  } // If timeZone parameter is set, use it as formatting option\n\n\n  const {\n    timeZone\n  } = opts;\n  const timeZoneMaybe = getTimeZoneMaybe(timeZone); // By default we can use moment() directly but in tests we need to use a specific dates.\n  // Tests inject now() function to intl wich returns predefined date\n\n  const now = intl.now ? moment(intl.now()) : moment(); // isSame: if the two moments have different time zones, the time zone of the first moment will be used for the comparison.\n\n  const localizedNow = timeZoneMaybe.timeZone ? now.tz(timeZone) : now;\n\n  if (localizedNow.isSame(date, 'day')) {\n    // e.g. \"Today, 9:10 PM\"\n    const formattedTime = intl.formatDate(date, {\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    });\n    return `${todayString}, ${formattedTime}`;\n  } else if (localizedNow.isSame(date, 'week')) {\n    // e.g.\n    // en-US: \"Sun 6:02 PM\"\n    // en-GB: \"Sun 18:02\"\n    // fr-FR: \"dim. 18:02\"\n    return intl.formatDate(date, {\n      weekday: 'short',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    });\n  } else if (localizedNow.isSame(date, 'year')) {\n    // e.g.\n    // en-US: \"Jul 20, 6:02 PM\"\n    // en-GB: \"20 Jul, 18:02\"\n    // fr-FR: \"20 juil., 18:02\"\n    return intl.formatDate(date, {\n      month: 'short',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    });\n  } else {\n    // e.g.\n    // en-US: \"Jul 20, 2020, 6:02 PM\"\n    // en-GB: \"20 Jul 2020, 18:02\"\n    // fr-FR: \"20 juil. 2020, 18:02\"\n    return intl.formatDate(date, {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    });\n  }\n};\n/**\n * Formats date to into multiple different ways:\n * - date \"Mar 24\"\n * - time \"8:07 PM\"\n * - dateAndTime: \"Mar 24, 8:07 PM\"\n *\n * If date is on different year, it will show it.\n *\n * @param {Date} date to be formatted\n * @param {Object} intl Intl object from react-intl\n * @param {Object} [opts] options. Can be used to pass in timeZone. It should represent IANA time zone key.\n *\n * @returns {Object} \"{ date, time, dateAndTime }\"\n */\n\nexport const formatDateIntoPartials = (date, intl, opts = {}) => {\n  // If timeZone parameter is set, use it as formatting option\n  const {\n    timeZone\n  } = opts;\n  const timeZoneMaybe = getTimeZoneMaybe(timeZone); // By default we can use moment() directly but in tests we need to use a specific dates.\n  // Tests inject now() function to intl wich returns predefined date\n\n  const now = intl.now ? moment(intl.now()) : moment(); // isSame: if the two moments have different time zones, the time zone of the first moment will be used for the comparison.\n\n  const localizedNow = timeZoneMaybe.timeZone ? now.tz(timeZone) : now;\n  const yearMaybe = localizedNow.isSame(date, 'year') ? {} : {\n    year: 'numeric'\n  };\n  return {\n    date: intl.formatDate(date, {\n      month: 'short',\n      day: 'numeric',\n      ...yearMaybe,\n      ...timeZoneMaybe\n    }),\n    time: intl.formatDate(date, {\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    }),\n    dateAndTime: intl.formatDate(date, { ...yearMaybe,\n      month: 'short',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    })\n  };\n};\n/**\n * Parses given date string in ISO8601 format('YYYY-MM-DD') to date in\n * the given time zone.\n *\n * This is used in search when filtering by time-based availability.\n *\n * Example:\n * ('2020-04-15', 'Etc/UTC') => new Date('2020-04-15T00:00:00.000Z')\n * ('2020-04-15', 'Europe/Helsinki') => new Date('2020-04-14T21:00:00.000Z')\n *\n * @param {String} dateString in 'YYYY-MM-DD' format\n * @param {String} [timeZone] time zone id, see:\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n *\n * @returns {Date} date\n */\n\nexport const parseDateFromISO8601 = (dateString, timeZone = null) => {\n  return timeZone ? moment.tz(dateString, timeZone).toDate() : moment(dateString, 'YYYY-MM-DD').toDate();\n};\n/**\n * Converts date to string ISO8601 format ('YYYY-MM-DD').\n * This string is used e.g. in urlParam.\n *\n * @param {Date} date\n * @param {String} [timeZone] time zone id, see:\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n *\n * @returns {String} string in 'YYYY-MM-DD' format\n */\n\nexport const stringifyDateToISO8601 = (date, timeZone = null) => {\n  return timeZone ? moment(date).tz(timeZone).format('YYYY-MM-DD') : moment(date).format('YYYY-MM-DD');\n}; //////////\n// Misc //\n//////////\n\n/**\n * Format the given date to month id/string: 'YYYY-MM'.\n *\n * @param {Date} date to be formatted\n * @param {String} [timeZone] time zone name (optional parameter).\n *\n * @returns {String} formatted month string\n */\n\nexport const monthIdString = (date, timeZone = null) => {\n  return timeZone ? moment(date).tz(timeZone).format('YYYY-MM') : moment(date).format('YYYY-MM');\n};\n/**\n * Formats string ('YYYY-MM-DD') in given time zone to format ('0000-00-00T00:00:00.000Z') and adds one day.\n * This is used as end date of the search query.\n * One day must be added because end of the availability is exclusive in API.\n *\n * @param {String} string in 'YYYY-MM-DD'format\n * @param {String} timeZone time zone name.\n *\n * @returns {String} string in '0000-00-00T00:00:00.000Z' format\n */\n\nexport const getExclusiveEndDate = (dateString, timeZone) => {\n  return moment.tz(dateString, timeZone).add(1, 'days').startOf('day').toDate();\n};","map":{"version":3,"sources":["/Users/harryholcomb/Desktop/React Native/GitHub/Sharetribe/ftw-product/src/util/dates.js"],"names":["moment","START_DATE","END_DATE","isTimeZoneSupported","Intl","DateTimeFormat","dtf","resolvedOptions","timeZone","isValidTimeZone","format","e","isDate","d","Object","prototype","toString","call","Number","isNaN","getTime","isSameDate","a","b","isAfterDate","dateA","dateB","isAfter","timeOfDayFromLocalToTimeZone","date","tz","toDate","timeOfDayFromTimeZoneToLocal","getStartOf","unit","m","clone","startOf","addTime","offset","add","subtractTime","subtract","daysBetween","startDate","endDate","days","diff","Error","minutesBetween","minutes","diffInTime","useFloat","getTimeZoneMaybe","formatDateWithProximity","intl","todayString","opts","paramsValid","Date","timeZoneMaybe","now","localizedNow","isSame","formattedTime","formatDate","hour","minute","weekday","month","day","year","formatDateIntoPartials","yearMaybe","time","dateAndTime","parseDateFromISO8601","dateString","stringifyDateToISO8601","monthIdString","getExclusiveEndDate"],"mappings":"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","sourcesContent":["import moment from 'moment-timezone/builds/moment-timezone-with-data-10-year-range.min';\n\n/**\n * Input names for the DateRangePicker from react-dates.\n */\nexport const START_DATE = 'startDate';\nexport const END_DATE = 'endDate';\n\n/**\n * Check if the browser's DateTimeFormat API supports time zones.\n *\n * @returns {Boolean} true if the browser returns current time zone.\n */\nexport const isTimeZoneSupported = () => {\n  if (!Intl || typeof Intl === 'undefined' || typeof Intl.DateTimeFormat === 'undefined') {\n    return false;\n  }\n\n  const dtf = new Intl.DateTimeFormat();\n  if (typeof dtf === 'undefined' || typeof dtf.resolvedOptions === 'undefined') {\n    return false;\n  }\n  return !!dtf.resolvedOptions().timeZone;\n};\n\n/**\n * Check if the given time zone key is valid.\n *\n * @param {String} timeZone time zone id, see:\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n *\n * @returns {Boolean} true if the browser recognizes the key.\n */\nexport const isValidTimeZone = timeZone => {\n  try {\n    new Intl.DateTimeFormat('en-US', { timeZone }).format();\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Check that the given parameter is a Date object.\n *\n * @param {Date} object that should be a Date.\n *\n * @returns {boolean} true if given parameter is a Date object.\n */\nexport const isDate = d =>\n  d && Object.prototype.toString.call(d) === '[object Date]' && !Number.isNaN(d.getTime());\n\n/**\n * Check if the given parameters represent the same Date value (timestamps are compared)\n *\n * @param {Date} first param that should be a Date and it should have same timestamp as second param.\n * @param {Date} second param that should be a Date and it should have same timestamp as second param.\n *\n * @returns {boolean} true if given parameters have the same timestamp.\n */\nexport const isSameDate = (a, b) => a && isDate(a) && b && isDate(b) && a.getTime() === b.getTime();\n\n/**\n * Compare is dateA is after dateB\n *\n * @param {Date} dateA date instance\n * @param {Date} dateB date instance\n *\n * @returns {Date} true if dateA is after dateB\n */\nexport const isAfterDate = (dateA, dateB) => {\n  return moment(dateA).isAfter(moment(dateB));\n};\n\n////////////////////////////////////////////////////////////////////\n// Manipulate time: time-of-day between different time zones etc. //\n////////////////////////////////////////////////////////////////////\n\n/**\n * Returns a new date, which indicates the same time of day in a given time zone\n * as given date is in local time zone\n *\n * @param {Date} date\n * @param {String} timeZone\n *\n * @returns {Date} date in given time zone\n */\nexport const timeOfDayFromLocalToTimeZone = (date, timeZone) => {\n  return moment.tz(moment(date).format('YYYY-MM-DD HH:mm:ss'), timeZone).toDate();\n};\n\n/**\n * Returns a new date, which indicates the same time of day in a local time zone\n * as given date is in specified time zone\n *\n * @param {Date} date\n * @param {String} timeZone\n *\n * @returns {Date} date in given time zone\n */\nexport const timeOfDayFromTimeZoneToLocal = (date, timeZone) => {\n  return moment(\n    moment(date)\n      .tz(timeZone)\n      .format('YYYY-MM-DD HH:mm:ss')\n  ).toDate();\n};\n\n/**\n * Get start of time unit (e.g. start of day)\n *\n * @param {Date} date date instance to be converted\n * @param {String} unit time-unit (e.g. \"day\")\n * @param {String} timeZone time zone id\n *\n * @returns {Date} date object converted to the start of given unit\n */\nexport const getStartOf = (date, unit, timeZone) => {\n  const m = timeZone\n    ? moment(date)\n        .clone()\n        .tz(timeZone)\n    : moment(date).clone();\n\n  return m.startOf(unit).toDate();\n};\n\n/**\n * Adds time-units to the date\n *\n * @param {Date} date date to be manipulated\n * @param {int} offset offset of time-units (e.g. \"3\" days)\n * @param {String} unit time-unit (e.g. \"days\")\n * @param {String} timeZone time zone name\n *\n * @returns {Date} date with given offset added\n */\nexport const addTime = (date, offset, unit, timeZone) => {\n  const m = timeZone\n    ? moment(date)\n        .clone()\n        .tz(timeZone)\n    : moment(date).clone();\n  return m.add(offset, unit).toDate();\n};\n\n/**\n * Subtract time-units from the date\n *\n * @param {Date} date date to be manipulated\n * @param {int} offset offset of time-units (e.g. \"3\" days)\n * @param {String} unit time-unit (e.g. \"days\")\n * @param {String} timeZone time zone name\n *\n * @returns {Date} date with given offset subtracted\n */\nexport const subtractTime = (date, offset, unit, timeZone) => {\n  const m = timeZone\n    ? moment(date)\n        .clone()\n        .tz(timeZone)\n    : moment(date).clone();\n  return m.subtract(offset, unit).toDate();\n};\n\n///////////////\n// Durations //\n///////////////\n\n/**\n * Calculate the number of days between the given dates.\n * This uses moment#diff and, therefore, it just checks,\n * if there are 1000x60x60x24 milliseconds between date objects.\n *\n * Note: This should not be used for checking if the local date has\n *       changed between \"2021-04-07 23:00\" and \"2021-04-08 05:00\".\n *\n * @param {Date} startDate start of the time period\n * @param {Date} endDate end of the time period. NOTE: with daily\n * bookings, it is expected that this date is the exclusive end date,\n * i.e. the last day of the booking is the previous date of this end\n * date.\n *\n * @throws Will throw if the end date is before the start date\n * @returns {Number} number of days between the given dates\n */\nexport const daysBetween = (startDate, endDate) => {\n  const days = moment(endDate).diff(startDate, 'days');\n  if (days < 0) {\n    throw new Error('End date cannot be before start date');\n  }\n  return days;\n};\n\n/**\n * Count the number of minutes between the given Date objects.\n *\n * @param {Date} startDate start of the time period\n * @param {Date} endDate end of the time period.\n *\n * @returns {Number} number of minutes between the given Date objects\n */\nexport const minutesBetween = (startDate, endDate) => {\n  const minutes = moment(endDate).diff(startDate, 'minutes');\n  return minutes;\n};\n\n/**\n * Calculate the difference between the given dates\n *\n * @param {Date} startDate start of the time period\n * @param {Date} endDate end of the time period.\n * @param {String} unit time unit. E.g. 'years'.\n * @param {String} useFloat Should return floating point numbers?\n *\n * @returns {Number} time difference between the given Date objects using given unit\n */\nexport const diffInTime = (startDate, endDate, unit, useFloat = false) => {\n  return moment(startDate).diff(endDate, unit, useFloat);\n};\n\n////////////////////////////\n// Parsing and formatting //\n////////////////////////////\n\nconst getTimeZoneMaybe = timeZone => {\n  if (timeZone) {\n    if (!isTimeZoneSupported()) {\n      throw new Error(`Your browser doesn't support time zones.`);\n    }\n\n    if (!isValidTimeZone(timeZone)) {\n      throw new Error(`Given time zone key (${timeZone}) is not valid.`);\n    }\n    return { timeZone };\n  }\n  return {};\n};\n\n/**\n * Format the given date. Printed string depends on how close the date is the current day.\n * E.g. \"Today, 9:10 PM\", \"Sun 6:02 PM\", \"Jul 20, 6:02 PM\", \"Jul 20 2020, 6:02 PM\"\n *\n * @param {Date} date Date to be formatted\n * @param {Object} intl Intl object from react-intl\n * @param {String} todayString translation for the current day\n * @param {Object} [opts] options. Can be used to pass in timeZone. It should represent IANA time zone key.\n *\n * @returns {String} formatted date\n */\nexport const formatDateWithProximity = (date, intl, todayString, opts = {}) => {\n  const paramsValid = intl && date instanceof Date && typeof todayString === 'string';\n  if (!paramsValid) {\n    throw new Error(`Invalid params for formatDate: (${date}, ${intl}, ${todayString})`);\n  }\n\n  // If timeZone parameter is set, use it as formatting option\n  const { timeZone } = opts;\n  const timeZoneMaybe = getTimeZoneMaybe(timeZone);\n\n  // By default we can use moment() directly but in tests we need to use a specific dates.\n  // Tests inject now() function to intl wich returns predefined date\n  const now = intl.now ? moment(intl.now()) : moment();\n\n  // isSame: if the two moments have different time zones, the time zone of the first moment will be used for the comparison.\n  const localizedNow = timeZoneMaybe.timeZone ? now.tz(timeZone) : now;\n\n  if (localizedNow.isSame(date, 'day')) {\n    // e.g. \"Today, 9:10 PM\"\n    const formattedTime = intl.formatDate(date, {\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe,\n    });\n    return `${todayString}, ${formattedTime}`;\n  } else if (localizedNow.isSame(date, 'week')) {\n    // e.g.\n    // en-US: \"Sun 6:02 PM\"\n    // en-GB: \"Sun 18:02\"\n    // fr-FR: \"dim. 18:02\"\n    return intl.formatDate(date, {\n      weekday: 'short',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe,\n    });\n  } else if (localizedNow.isSame(date, 'year')) {\n    // e.g.\n    // en-US: \"Jul 20, 6:02 PM\"\n    // en-GB: \"20 Jul, 18:02\"\n    // fr-FR: \"20 juil., 18:02\"\n    return intl.formatDate(date, {\n      month: 'short',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe,\n    });\n  } else {\n    // e.g.\n    // en-US: \"Jul 20, 2020, 6:02 PM\"\n    // en-GB: \"20 Jul 2020, 18:02\"\n    // fr-FR: \"20 juil. 2020, 18:02\"\n    return intl.formatDate(date, {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe,\n    });\n  }\n};\n\n/**\n * Formats date to into multiple different ways:\n * - date \"Mar 24\"\n * - time \"8:07 PM\"\n * - dateAndTime: \"Mar 24, 8:07 PM\"\n *\n * If date is on different year, it will show it.\n *\n * @param {Date} date to be formatted\n * @param {Object} intl Intl object from react-intl\n * @param {Object} [opts] options. Can be used to pass in timeZone. It should represent IANA time zone key.\n *\n * @returns {Object} \"{ date, time, dateAndTime }\"\n */\nexport const formatDateIntoPartials = (date, intl, opts = {}) => {\n  // If timeZone parameter is set, use it as formatting option\n  const { timeZone } = opts;\n  const timeZoneMaybe = getTimeZoneMaybe(timeZone);\n\n  // By default we can use moment() directly but in tests we need to use a specific dates.\n  // Tests inject now() function to intl wich returns predefined date\n  const now = intl.now ? moment(intl.now()) : moment();\n\n  // isSame: if the two moments have different time zones, the time zone of the first moment will be used for the comparison.\n  const localizedNow = timeZoneMaybe.timeZone ? now.tz(timeZone) : now;\n  const yearMaybe = localizedNow.isSame(date, 'year') ? {} : { year: 'numeric' };\n\n  return {\n    date: intl.formatDate(date, {\n      month: 'short',\n      day: 'numeric',\n      ...yearMaybe,\n      ...timeZoneMaybe,\n    }),\n    time: intl.formatDate(date, {\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe,\n    }),\n    dateAndTime: intl.formatDate(date, {\n      ...yearMaybe,\n      month: 'short',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe,\n    }),\n  };\n};\n\n/**\n * Parses given date string in ISO8601 format('YYYY-MM-DD') to date in\n * the given time zone.\n *\n * This is used in search when filtering by time-based availability.\n *\n * Example:\n * ('2020-04-15', 'Etc/UTC') => new Date('2020-04-15T00:00:00.000Z')\n * ('2020-04-15', 'Europe/Helsinki') => new Date('2020-04-14T21:00:00.000Z')\n *\n * @param {String} dateString in 'YYYY-MM-DD' format\n * @param {String} [timeZone] time zone id, see:\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n *\n * @returns {Date} date\n */\nexport const parseDateFromISO8601 = (dateString, timeZone = null) => {\n  return timeZone\n    ? moment.tz(dateString, timeZone).toDate()\n    : moment(dateString, 'YYYY-MM-DD').toDate();\n};\n\n/**\n * Converts date to string ISO8601 format ('YYYY-MM-DD').\n * This string is used e.g. in urlParam.\n *\n * @param {Date} date\n * @param {String} [timeZone] time zone id, see:\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n *\n * @returns {String} string in 'YYYY-MM-DD' format\n */\nexport const stringifyDateToISO8601 = (date, timeZone = null) => {\n  return timeZone\n    ? moment(date)\n        .tz(timeZone)\n        .format('YYYY-MM-DD')\n    : moment(date).format('YYYY-MM-DD');\n};\n\n//////////\n// Misc //\n//////////\n\n/**\n * Format the given date to month id/string: 'YYYY-MM'.\n *\n * @param {Date} date to be formatted\n * @param {String} [timeZone] time zone name (optional parameter).\n *\n * @returns {String} formatted month string\n */\nexport const monthIdString = (date, timeZone = null) => {\n  return timeZone\n    ? moment(date)\n        .tz(timeZone)\n        .format('YYYY-MM')\n    : moment(date).format('YYYY-MM');\n};\n\n/**\n * Formats string ('YYYY-MM-DD') in given time zone to format ('0000-00-00T00:00:00.000Z') and adds one day.\n * This is used as end date of the search query.\n * One day must be added because end of the availability is exclusive in API.\n *\n * @param {String} string in 'YYYY-MM-DD'format\n * @param {String} timeZone time zone name.\n *\n * @returns {String} string in '0000-00-00T00:00:00.000Z' format\n */\nexport const getExclusiveEndDate = (dateString, timeZone) => {\n  return moment\n    .tz(dateString, timeZone)\n    .add(1, 'days')\n    .startOf('day')\n    .toDate();\n};\n"]},"metadata":{},"sourceType":"module"}