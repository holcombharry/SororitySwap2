{"ast":null,"code":"var _jsxFileName = \"/Users/harryholcomb/Desktop/React Native/GitHub/Sharetribe/ftw-product/src/util/contextHelpers.js\";\nimport React, { Component as ReactComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport throttle from 'lodash/throttle';\n/**\n * A higher order component (HOC) to take the togglePageClassNames function from\n * the context that the Page component has provided.\n */\n\nexport const withTogglePageClassNames = Component => {\n  const WithTogglePageClassNamesComponent = (props, context) => /*#__PURE__*/React.createElement(Component, Object.assign({\n    togglePageClassNames: context.togglePageClassNames\n  }, props, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 11,\n      columnNumber: 5\n    }\n  }));\n\n  WithTogglePageClassNamesComponent.displayName = `withTogglePageClassNames(${Component.displayName || Component.name})`;\n  const {\n    func\n  } = PropTypes;\n  WithTogglePageClassNamesComponent.contextTypes = {\n    togglePageClassNames: func.isRequired\n  };\n  return WithTogglePageClassNamesComponent;\n};\n/**\n * A higher order component (HOC) that provides the current viewport\n * dimensions to the wrapped component as a `viewport` prop that has\n * the shape `{ width: 600, height: 400}`.\n */\n\nexport const withViewport = Component => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const WAIT_MS = 100;\n\n  class WithViewportComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.state = {\n        width: 0,\n        height: 0\n      };\n      this.handleWindowResize = this.handleWindowResize.bind(this);\n      this.setViewport = throttle(this.setViewport.bind(this), WAIT_MS);\n    }\n\n    componentDidMount() {\n      this.setViewport();\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n    }\n\n    handleWindowResize() {\n      this.setViewport();\n    }\n\n    setViewport() {\n      this.setState({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    }\n\n    render() {\n      const viewport = this.state;\n      const props = { ...this.props,\n        viewport\n      };\n      return /*#__PURE__*/React.createElement(Component, Object.assign({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 65,\n          columnNumber: 14\n        }\n      }));\n    }\n\n  }\n\n  WithViewportComponent.displayName = `withViewport(${Component.displayName || Component.name})`;\n  return WithViewportComponent;\n};\n/**\n * A higher order component (HOC) that provides dimensions to the wrapped component as a\n * `dimensions` prop that has the shape `{ width: 600, height: 400}`.\n *\n * @param {React.Component} Component to be wrapped by this HOC\n * @param {Object} options pass in options like maxWidth and maxHeight.\n *\n * @return {Object} HOC component which knows its dimensions\n */\n\nexport const withDimensions = (Component, options = {}) => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const THROTTLE_WAIT_MS = 200; // First render default wait after mounting (small wait for styled paint)\n\n  const RENDER_WAIT_MS = 100;\n\n  class WithDimensionsComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.element = null;\n      this.defaultRenderTimeout = null;\n      this.state = {\n        width: 0,\n        height: 0\n      };\n      this.handleWindowResize = throttle(this.handleWindowResize.bind(this), THROTTLE_WAIT_MS);\n      this.setDimensions = this.setDimensions.bind(this);\n    }\n\n    componentDidMount() {\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n      this.defaultRenderTimeout = window.setTimeout(() => {\n        this.setDimensions();\n      }, RENDER_WAIT_MS);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n      window.clearTimeout(this.defaultRenderTimeout);\n    }\n\n    handleWindowResize() {\n      window.requestAnimationFrame(() => {\n        this.setDimensions();\n      });\n    }\n\n    setDimensions() {\n      this.setState(prevState => {\n        const {\n          clientWidth,\n          clientHeight\n        } = this.element || {\n          clientWidth: 0,\n          clientHeight: 0\n        };\n        return {\n          width: clientWidth,\n          height: clientHeight\n        };\n      });\n    }\n\n    render() {\n      // Dimensions from state (i.e. dimension after previous resize)\n      // These are needed for component rerenders\n      const {\n        width,\n        height\n      } = this.state; // Current dimensions from element reference\n\n      const {\n        clientWidth,\n        clientHeight\n      } = this.element || {\n        clientWidth: 0,\n        clientHeight: 0\n      };\n      const hasDimensions = width !== 0 && height !== 0 || clientWidth !== 0 && clientHeight !== 0; // clientWidth and clientHeight\n\n      const currentDimensions = clientWidth !== 0 && clientHeight !== 0 ? {\n        width: clientWidth,\n        height: clientHeight\n      } : width !== 0 && height !== 0 ? {\n        width,\n        height\n      } : {};\n      const props = { ...this.props,\n        dimensions: currentDimensions\n      }; // lazyLoadWithDimensions HOC needs to take all given space\n      // unless max dimensions are provided through options.\n\n      const {\n        maxWidth,\n        maxHeight\n      } = options;\n      const maxWidthMaybe = maxWidth ? {\n        maxWidth\n      } : {};\n      const maxHeightMaybe = maxHeight ? {\n        maxHeight\n      } : {};\n      const style = maxWidth || maxHeight ? {\n        width: '100%',\n        height: '100%',\n        ...maxWidthMaybe,\n        ...maxHeightMaybe\n      } : {\n        position: 'absolute',\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n      return /*#__PURE__*/React.createElement(\"div\", {\n        ref: element => {\n          this.element = element;\n        },\n        style: style,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 162,\n          columnNumber: 9\n        }\n      }, hasDimensions ? /*#__PURE__*/React.createElement(Component, Object.assign({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 168,\n          columnNumber: 28\n        }\n      })) : null);\n    }\n\n  }\n\n  WithDimensionsComponent.displayName = `withDimensions(${Component.displayName || Component.name})`;\n  return WithDimensionsComponent;\n};\n/**\n * A higher order component (HOC) that lazy loads the current element and provides\n * dimensions to the wrapped component as a `dimensions` prop that has\n * the shape `{ width: 600, height: 400}`.\n *\n * @param {React.Component} Component to be wrapped by this HOC\n * @param {Object} options pass in options like maxWidth and maxHeight. To load component after\n * initial rendering has passed or after user has interacted with the window (e.g. scrolled),\n * use`loadAfterInitialRendering: 1500` (value should be milliseconds).\n *\n * @return {Object} HOC component which knows its dimensions\n */\n\nexport const lazyLoadWithDimensions = (Component, options = {}) => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const THROTTLE_WAIT_MS = 200; // First render default wait after mounting (small wait for styled paint)\n\n  const RENDER_WAIT_MS = 100; // Scrolling and other events that affect to viewport location have this safety margin\n  // for lazy loading\n\n  const NEAR_VIEWPORT_MARGIN = 50;\n\n  class LazyLoadWithDimensionsComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.element = null;\n      this.defaultRenderTimeout = null;\n      this.afterRenderTimeout = null;\n      this.state = {\n        width: 0,\n        height: 0\n      };\n      this.handleWindowResize = throttle(this.handleWindowResize.bind(this), THROTTLE_WAIT_MS);\n      this.isElementNearViewport = this.isElementNearViewport.bind(this);\n      this.setDimensions = this.setDimensions.bind(this);\n    }\n\n    componentDidMount() {\n      window.addEventListener('scroll', this.handleWindowResize);\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n      this.defaultRenderTimeout = window.setTimeout(() => {\n        if (this.isElementNearViewport(0)) {\n          this.setDimensions();\n        } else {\n          const loadAfterInitialRendering = options.loadAfterInitialRendering;\n\n          if (typeof loadAfterInitialRendering === 'number') {\n            this.afterRenderTimeout = window.setTimeout(() => {\n              window.requestAnimationFrame(() => {\n                this.setDimensions();\n              });\n            }, loadAfterInitialRendering);\n          }\n        }\n      }, RENDER_WAIT_MS);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('scroll', this.handleWindowResize);\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n      window.clearTimeout(this.defaultRenderTimeout);\n\n      if (this.afterRenderTimeout) {\n        window.clearTimeout(this.afterRenderTimeout);\n      }\n    }\n\n    handleWindowResize() {\n      const shouldLoadToImproveScrolling = typeof options.loadAfterInitialRendering === 'number';\n\n      if (this.isElementNearViewport(NEAR_VIEWPORT_MARGIN) || shouldLoadToImproveScrolling) {\n        window.requestAnimationFrame(() => {\n          this.setDimensions();\n        });\n      }\n    }\n\n    setDimensions() {\n      this.setState(prevState => {\n        const {\n          clientWidth,\n          clientHeight\n        } = this.element || {\n          clientWidth: 0,\n          clientHeight: 0\n        };\n        return {\n          width: clientWidth,\n          height: clientHeight\n        };\n      });\n    }\n\n    isElementNearViewport(safetyBoundary) {\n      if (this.element) {\n        const rect = this.element.getBoundingClientRect();\n        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;\n        return rect.top >= 0 && rect.top <= viewportHeight + safetyBoundary || rect.bottom >= -1 * safetyBoundary && rect.bottom <= viewportHeight;\n      }\n\n      return false;\n    }\n\n    render() {\n      const dimensions = this.state;\n      const {\n        width,\n        height\n      } = dimensions;\n      const props = { ...this.props,\n        dimensions\n      }; // lazyLoadWithDimensions HOC needs to take all given space\n      // unless max dimensions are provided through options.\n\n      const {\n        maxWidth,\n        maxHeight\n      } = options;\n      const maxWidthMaybe = maxWidth ? {\n        maxWidth\n      } : {};\n      const maxHeightMaybe = maxHeight ? {\n        maxHeight\n      } : {};\n      const style = maxWidth || maxHeight ? {\n        width: '100%',\n        height: '100%',\n        ...maxWidthMaybe,\n        ...maxHeightMaybe\n      } : {\n        position: 'absolute',\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n      return /*#__PURE__*/React.createElement(\"div\", {\n        ref: element => {\n          this.element = element;\n        },\n        style: style,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 295,\n          columnNumber: 9\n        }\n      }, width !== 0 && height !== 0 ? /*#__PURE__*/React.createElement(Component, Object.assign({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 301,\n          columnNumber: 42\n        }\n      })) : null);\n    }\n\n  }\n\n  LazyLoadWithDimensionsComponent.displayName = `lazyLoadWithDimensions(${Component.displayName || Component.name})`;\n  return LazyLoadWithDimensionsComponent;\n};","map":{"version":3,"sources":["/Users/harryholcomb/Desktop/React Native/GitHub/Sharetribe/ftw-product/src/util/contextHelpers.js"],"names":["React","Component","ReactComponent","PropTypes","throttle","withTogglePageClassNames","WithTogglePageClassNamesComponent","props","context","togglePageClassNames","displayName","name","func","contextTypes","isRequired","withViewport","WAIT_MS","WithViewportComponent","constructor","state","width","height","handleWindowResize","bind","setViewport","componentDidMount","window","addEventListener","componentWillUnmount","removeEventListener","setState","innerWidth","innerHeight","render","viewport","withDimensions","options","THROTTLE_WAIT_MS","RENDER_WAIT_MS","WithDimensionsComponent","element","defaultRenderTimeout","setDimensions","setTimeout","clearTimeout","requestAnimationFrame","prevState","clientWidth","clientHeight","hasDimensions","currentDimensions","dimensions","maxWidth","maxHeight","maxWidthMaybe","maxHeightMaybe","style","position","top","right","bottom","left","lazyLoadWithDimensions","NEAR_VIEWPORT_MARGIN","LazyLoadWithDimensionsComponent","afterRenderTimeout","isElementNearViewport","loadAfterInitialRendering","shouldLoadToImproveScrolling","safetyBoundary","rect","getBoundingClientRect","viewportHeight","document","documentElement"],"mappings":"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","sourcesContent":["import React, { Component as ReactComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport throttle from 'lodash/throttle';\n\n/**\n * A higher order component (HOC) to take the togglePageClassNames function from\n * the context that the Page component has provided.\n */\nexport const withTogglePageClassNames = Component => {\n  const WithTogglePageClassNamesComponent = (props, context) => (\n    <Component togglePageClassNames={context.togglePageClassNames} {...props} />\n  );\n\n  WithTogglePageClassNamesComponent.displayName = `withTogglePageClassNames(${Component.displayName ||\n    Component.name})`;\n\n  const { func } = PropTypes;\n\n  WithTogglePageClassNamesComponent.contextTypes = {\n    togglePageClassNames: func.isRequired,\n  };\n\n  return WithTogglePageClassNamesComponent;\n};\n\n/**\n * A higher order component (HOC) that provides the current viewport\n * dimensions to the wrapped component as a `viewport` prop that has\n * the shape `{ width: 600, height: 400}`.\n */\nexport const withViewport = Component => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const WAIT_MS = 100;\n\n  class WithViewportComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.state = { width: 0, height: 0 };\n      this.handleWindowResize = this.handleWindowResize.bind(this);\n      this.setViewport = throttle(this.setViewport.bind(this), WAIT_MS);\n    }\n    componentDidMount() {\n      this.setViewport();\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n    }\n    componentWillUnmount() {\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n    }\n    handleWindowResize() {\n      this.setViewport();\n    }\n    setViewport() {\n      this.setState({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }\n    render() {\n      const viewport = this.state;\n      const props = { ...this.props, viewport };\n      return <Component {...props} />;\n    }\n  }\n\n  WithViewportComponent.displayName = `withViewport(${Component.displayName || Component.name})`;\n\n  return WithViewportComponent;\n};\n\n/**\n * A higher order component (HOC) that provides dimensions to the wrapped component as a\n * `dimensions` prop that has the shape `{ width: 600, height: 400}`.\n *\n * @param {React.Component} Component to be wrapped by this HOC\n * @param {Object} options pass in options like maxWidth and maxHeight.\n *\n * @return {Object} HOC component which knows its dimensions\n */\nexport const withDimensions = (Component, options = {}) => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const THROTTLE_WAIT_MS = 200;\n  // First render default wait after mounting (small wait for styled paint)\n  const RENDER_WAIT_MS = 100;\n\n  class WithDimensionsComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.element = null;\n      this.defaultRenderTimeout = null;\n\n      this.state = { width: 0, height: 0 };\n\n      this.handleWindowResize = throttle(this.handleWindowResize.bind(this), THROTTLE_WAIT_MS);\n      this.setDimensions = this.setDimensions.bind(this);\n    }\n\n    componentDidMount() {\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n\n      this.defaultRenderTimeout = window.setTimeout(() => {\n        this.setDimensions();\n      }, RENDER_WAIT_MS);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n      window.clearTimeout(this.defaultRenderTimeout);\n    }\n\n    handleWindowResize() {\n      window.requestAnimationFrame(() => {\n        this.setDimensions();\n      });\n    }\n\n    setDimensions() {\n      this.setState(prevState => {\n        const { clientWidth, clientHeight } = this.element || { clientWidth: 0, clientHeight: 0 };\n        return { width: clientWidth, height: clientHeight };\n      });\n    }\n\n    render() {\n      // Dimensions from state (i.e. dimension after previous resize)\n      // These are needed for component rerenders\n      const { width, height } = this.state;\n\n      // Current dimensions from element reference\n      const { clientWidth, clientHeight } = this.element || { clientWidth: 0, clientHeight: 0 };\n      const hasDimensions =\n        (width !== 0 && height !== 0) || (clientWidth !== 0 && clientHeight !== 0);\n\n      // clientWidth and clientHeight\n      const currentDimensions =\n        clientWidth !== 0 && clientHeight !== 0\n          ? { width: clientWidth, height: clientHeight }\n          : width !== 0 && height !== 0\n          ? { width, height }\n          : {};\n\n      const props = { ...this.props, dimensions: currentDimensions };\n\n      // lazyLoadWithDimensions HOC needs to take all given space\n      // unless max dimensions are provided through options.\n      const { maxWidth, maxHeight } = options;\n      const maxWidthMaybe = maxWidth ? { maxWidth } : {};\n      const maxHeightMaybe = maxHeight ? { maxHeight } : {};\n      const style =\n        maxWidth || maxHeight\n          ? { width: '100%', height: '100%', ...maxWidthMaybe, ...maxHeightMaybe }\n          : { position: 'absolute', top: 0, right: 0, bottom: 0, left: 0 };\n\n      return (\n        <div\n          ref={element => {\n            this.element = element;\n          }}\n          style={style}\n        >\n          {hasDimensions ? <Component {...props} /> : null}\n        </div>\n      );\n    }\n  }\n\n  WithDimensionsComponent.displayName = `withDimensions(${Component.displayName ||\n    Component.name})`;\n\n  return WithDimensionsComponent;\n};\n\n/**\n * A higher order component (HOC) that lazy loads the current element and provides\n * dimensions to the wrapped component as a `dimensions` prop that has\n * the shape `{ width: 600, height: 400}`.\n *\n * @param {React.Component} Component to be wrapped by this HOC\n * @param {Object} options pass in options like maxWidth and maxHeight. To load component after\n * initial rendering has passed or after user has interacted with the window (e.g. scrolled),\n * use`loadAfterInitialRendering: 1500` (value should be milliseconds).\n *\n * @return {Object} HOC component which knows its dimensions\n */\nexport const lazyLoadWithDimensions = (Component, options = {}) => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const THROTTLE_WAIT_MS = 200;\n  // First render default wait after mounting (small wait for styled paint)\n  const RENDER_WAIT_MS = 100;\n\n  // Scrolling and other events that affect to viewport location have this safety margin\n  // for lazy loading\n  const NEAR_VIEWPORT_MARGIN = 50;\n\n  class LazyLoadWithDimensionsComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.element = null;\n      this.defaultRenderTimeout = null;\n      this.afterRenderTimeout = null;\n\n      this.state = { width: 0, height: 0 };\n\n      this.handleWindowResize = throttle(this.handleWindowResize.bind(this), THROTTLE_WAIT_MS);\n      this.isElementNearViewport = this.isElementNearViewport.bind(this);\n      this.setDimensions = this.setDimensions.bind(this);\n    }\n\n    componentDidMount() {\n      window.addEventListener('scroll', this.handleWindowResize);\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n\n      this.defaultRenderTimeout = window.setTimeout(() => {\n        if (this.isElementNearViewport(0)) {\n          this.setDimensions();\n        } else {\n          const loadAfterInitialRendering = options.loadAfterInitialRendering;\n          if (typeof loadAfterInitialRendering === 'number') {\n            this.afterRenderTimeout = window.setTimeout(() => {\n              window.requestAnimationFrame(() => {\n                this.setDimensions();\n              });\n            }, loadAfterInitialRendering);\n          }\n        }\n      }, RENDER_WAIT_MS);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('scroll', this.handleWindowResize);\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n      window.clearTimeout(this.defaultRenderTimeout);\n\n      if (this.afterRenderTimeout) {\n        window.clearTimeout(this.afterRenderTimeout);\n      }\n    }\n\n    handleWindowResize() {\n      const shouldLoadToImproveScrolling = typeof options.loadAfterInitialRendering === 'number';\n      if (this.isElementNearViewport(NEAR_VIEWPORT_MARGIN) || shouldLoadToImproveScrolling) {\n        window.requestAnimationFrame(() => {\n          this.setDimensions();\n        });\n      }\n    }\n\n    setDimensions() {\n      this.setState(prevState => {\n        const { clientWidth, clientHeight } = this.element || { clientWidth: 0, clientHeight: 0 };\n        return { width: clientWidth, height: clientHeight };\n      });\n    }\n\n    isElementNearViewport(safetyBoundary) {\n      if (this.element) {\n        const rect = this.element.getBoundingClientRect();\n        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;\n\n        return (\n          (rect.top >= 0 && rect.top <= viewportHeight + safetyBoundary) ||\n          (rect.bottom >= -1 * safetyBoundary && rect.bottom <= viewportHeight)\n        );\n      }\n      return false;\n    }\n\n    render() {\n      const dimensions = this.state;\n      const { width, height } = dimensions;\n      const props = { ...this.props, dimensions };\n\n      // lazyLoadWithDimensions HOC needs to take all given space\n      // unless max dimensions are provided through options.\n      const { maxWidth, maxHeight } = options;\n      const maxWidthMaybe = maxWidth ? { maxWidth } : {};\n      const maxHeightMaybe = maxHeight ? { maxHeight } : {};\n      const style =\n        maxWidth || maxHeight\n          ? { width: '100%', height: '100%', ...maxWidthMaybe, ...maxHeightMaybe }\n          : { position: 'absolute', top: 0, right: 0, bottom: 0, left: 0 };\n\n      return (\n        <div\n          ref={element => {\n            this.element = element;\n          }}\n          style={style}\n        >\n          {width !== 0 && height !== 0 ? <Component {...props} /> : null}\n        </div>\n      );\n    }\n  }\n\n  LazyLoadWithDimensionsComponent.displayName = `lazyLoadWithDimensions(${Component.displayName ||\n    Component.name})`;\n\n  return LazyLoadWithDimensionsComponent;\n};\n"]},"metadata":{},"sourceType":"module"}