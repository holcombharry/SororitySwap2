{"ast":null,"code":"var _jsxFileName = \"/Users/harryholcomb/Desktop/React Native/GitHub/Sharetribe/ftw-product/src/components/Menu/Menu.js\";\n\n/**\n * Menu is component that shows extra content when it is clicked.\n * Clicking it toggles visibility of MenuContent.\n *\n * Example:\n *  <Menu>\n *    <MenuLabel>\n *      <span>Open menu</span>\n *    </MenuLabel>\n *    <MenuContent>\n *      <MenuItem key=\"first item\">\n *        <Button onClick={onClick}>Click this</Button>\n *      </MenuItem>\n *    </MenuContent>\n *  </Menu>\n *\n */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { MenuContent, MenuLabel } from '../../components';\nimport css from './Menu.module.css';\nconst KEY_CODE_ESCAPE = 27;\nconst CONTENT_PLACEMENT_OFFSET = 0;\nconst CONTENT_TO_LEFT = 'left';\nconst CONTENT_TO_RIGHT = 'right';\nconst MAX_MOBILE_SCREEN_WIDTH = 767;\n\nconst isControlledMenu = (isOpenProp, onToggleActiveProp) => {\n  return isOpenProp !== null && onToggleActiveProp !== null;\n};\n\nclass Menu extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isOpen: false,\n      ready: false\n    };\n    const {\n      isOpen,\n      onToggleActive\n    } = props;\n    const isIndependentMenu = isOpen === null && onToggleActive === null;\n\n    if (!(isIndependentMenu || isControlledMenu(isOpen, onToggleActive))) {\n      throw new Error(`Menu has invalid props:\n          Both isOpen and onToggleActive need to be defined (controlled menu),\n          or neither of them (menu uses its own state management).`);\n    }\n\n    this.onBlur = this.onBlur.bind(this);\n    this.onKeyDown = this.onKeyDown.bind(this);\n    this.toggleOpen = this.toggleOpen.bind(this);\n    this.prepareChildren = this.prepareChildren.bind(this);\n    this.positionStyleForMenuContent = this.positionStyleForMenuContent.bind(this);\n    this.positionStyleForArrow = this.positionStyleForArrow.bind(this);\n    this.menu = null;\n    this.menuContent = null;\n  }\n\n  componentDidMount() {\n    // Menu needs to know about DOM before it can calculate it's size proberly.\n    this.setState({\n      ready: true\n    });\n  }\n\n  onBlur(event) {\n    // FocusEvent is fired faster than the link elements native click handler\n    // gets its own event. Therefore, we need to check the origin of this FocusEvent.\n    if (!this.menu.contains(event.relatedTarget)) {\n      const {\n        isOpen,\n        onToggleActive\n      } = this.props;\n\n      if (isControlledMenu(isOpen, onToggleActive)) {\n        onToggleActive(false);\n      } else {\n        this.setState({\n          isOpen: false\n        });\n      }\n    }\n  }\n\n  onKeyDown(e) {\n    // Gather all escape presses to close menu\n    if (e.keyCode === KEY_CODE_ESCAPE) {\n      this.toggleOpen(false);\n    }\n  }\n\n  toggleOpen(enforcedState) {\n    // If state is handled outside of Menu component, we call a passed in onToggleActive func\n    const {\n      isOpen,\n      onToggleActive\n    } = this.props;\n\n    if (isControlledMenu(isOpen, onToggleActive)) {\n      const isMenuOpen = enforcedState != null ? enforcedState : !isOpen;\n      onToggleActive(isMenuOpen);\n    } else {\n      // If state is handled inside of Menu component, set state\n      this.setState(prevState => {\n        const isMenuOpen = enforcedState != null ? enforcedState : !prevState.isOpen;\n        return {\n          isOpen: isMenuOpen\n        };\n      });\n    }\n  }\n\n  positionStyleForMenuContent(contentPosition) {\n    if (this.menu && this.menuContent) {\n      const windowWidth = window.innerWidth;\n      const rect = this.menu.getBoundingClientRect(); // Calculate wether we should show the menu to the left of the component or right\n\n      const distanceToRight = windowWidth - rect.right;\n      const menuWidth = this.menu.offsetWidth;\n      const contentWidthBiggerThanLabel = this.menuContent.offsetWidth - menuWidth;\n      const usePositionLeftFromLabel = contentPosition === CONTENT_TO_LEFT;\n      const contentPlacementOffset = this.props.contentPlacementOffset;\n\n      if (windowWidth <= MAX_MOBILE_SCREEN_WIDTH) {\n        // Take full screen width on mobile\n        return {\n          left: -1 * (rect.left - 24),\n          width: 'calc(100vw - 48px)'\n        };\n      } // Render menu content to the left according to the contentPosition\n      // prop or if the content does not fit to the right. Otherwise render to\n      // the right.\n\n\n      return usePositionLeftFromLabel || distanceToRight < contentWidthBiggerThanLabel ? {\n        right: contentPlacementOffset,\n        minWidth: menuWidth\n      } : {\n        left: contentPlacementOffset,\n        minWidth: menuWidth\n      };\n    } // When the MenuContent is rendered for the first time\n    // (for the sake of width calculation),\n    // move it outside of viewport to prevent possible overflow.\n\n\n    return this.state.isOpen ? {} : {\n      left: '-10000px'\n    };\n  }\n\n  positionStyleForArrow(isPositionedRight) {\n    if (this.menu) {\n      const menuWidth = this.menu.offsetWidth;\n      const contentPlacementOffset = this.props.contentPlacementOffset;\n      return isPositionedRight ? Math.floor(menuWidth / 2) - contentPlacementOffset : Math.floor(menuWidth / 2);\n    }\n\n    return 0;\n  }\n\n  prepareChildren() {\n    if (React.Children.count(this.props.children) !== 2) {\n      throw new Error('Menu needs to have two children: MenuLabel and MenuContent.');\n    }\n\n    return React.Children.map(this.props.children, child => {\n      const {\n        isOpen: isOpenProp,\n        onToggleActive\n      } = this.props;\n      const isOpen = isControlledMenu(isOpenProp, onToggleActive) ? isOpenProp : this.state.isOpen;\n\n      if (child.type === MenuLabel) {\n        // MenuLabel needs toggleOpen function\n        // We pass that directly  so that component user doesn't need to worry about that\n        return /*#__PURE__*/React.cloneElement(child, {\n          isOpen,\n          onToggleActive: this.toggleOpen\n        });\n      } else if (child.type === MenuContent) {\n        // MenuContent needs some styling data (width, arrowPosition, and isOpen info)\n        // We pass those directly so that component user doesn't need to worry about those.\n        const {\n          contentPosition,\n          useArrow\n        } = this.props;\n        const positionStyles = this.positionStyleForMenuContent(contentPosition);\n        const arrowPosition = useArrow ? this.positionStyleForArrow(positionStyles.right != null) : null;\n        return /*#__PURE__*/React.cloneElement(child, {\n          arrowPosition,\n          contentRef: node => {\n            this.menuContent = node;\n          },\n          isOpen,\n          style: { ...child.props.style,\n            ...positionStyles\n          }\n        });\n      } else {\n        throw new Error('Menu has an unknown child. Only MenuLabel and MenuContent are allowed.');\n      }\n    });\n  }\n\n  render() {\n    const {\n      className,\n      rootClassName\n    } = this.props;\n    const rootClass = rootClassName || css.root;\n    const classes = classNames(rootClass, className);\n    const menuChildren = this.state.ready ? this.prepareChildren() : null;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: classes,\n      onBlur: this.onBlur,\n      tabIndex: 0,\n      onKeyDown: this.onKeyDown,\n      ref: c => {\n        this.menu = c;\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 193,\n        columnNumber: 7\n      }\n    }, menuChildren);\n  }\n\n}\n\nMenu.defaultProps = {\n  className: null,\n  rootClassName: '',\n  contentPlacementOffset: CONTENT_PLACEMENT_OFFSET,\n  contentPosition: CONTENT_TO_RIGHT,\n  isOpen: null,\n  onToggleActive: null,\n  useArrow: true\n};\nconst {\n  bool,\n  func,\n  node,\n  number,\n  string\n} = PropTypes;\nMenu.propTypes = {\n  children: node.isRequired,\n  className: string,\n  rootClassName: string,\n  contentPosition: string,\n  contentPlacementOffset: number,\n  useArrow: bool,\n  isOpen: bool,\n  onToggleActive: func\n};\nexport default Menu;","map":{"version":3,"sources":["/Users/harryholcomb/Desktop/React Native/GitHub/Sharetribe/ftw-product/src/components/Menu/Menu.js"],"names":["React","Component","PropTypes","classNames","MenuContent","MenuLabel","css","KEY_CODE_ESCAPE","CONTENT_PLACEMENT_OFFSET","CONTENT_TO_LEFT","CONTENT_TO_RIGHT","MAX_MOBILE_SCREEN_WIDTH","isControlledMenu","isOpenProp","onToggleActiveProp","Menu","constructor","props","state","isOpen","ready","onToggleActive","isIndependentMenu","Error","onBlur","bind","onKeyDown","toggleOpen","prepareChildren","positionStyleForMenuContent","positionStyleForArrow","menu","menuContent","componentDidMount","setState","event","contains","relatedTarget","e","keyCode","enforcedState","isMenuOpen","prevState","contentPosition","windowWidth","window","innerWidth","rect","getBoundingClientRect","distanceToRight","right","menuWidth","offsetWidth","contentWidthBiggerThanLabel","usePositionLeftFromLabel","contentPlacementOffset","left","width","minWidth","isPositionedRight","Math","floor","Children","count","children","map","child","type","cloneElement","useArrow","positionStyles","arrowPosition","contentRef","node","style","render","className","rootClassName","rootClass","root","classes","menuChildren","c","defaultProps","bool","func","number","string","propTypes","isRequired"],"mappings":"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","sourcesContent":["/**\n * Menu is component that shows extra content when it is clicked.\n * Clicking it toggles visibility of MenuContent.\n *\n * Example:\n *  <Menu>\n *    <MenuLabel>\n *      <span>Open menu</span>\n *    </MenuLabel>\n *    <MenuContent>\n *      <MenuItem key=\"first item\">\n *        <Button onClick={onClick}>Click this</Button>\n *      </MenuItem>\n *    </MenuContent>\n *  </Menu>\n *\n */\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\n\nimport { MenuContent, MenuLabel } from '../../components';\nimport css from './Menu.module.css';\n\nconst KEY_CODE_ESCAPE = 27;\nconst CONTENT_PLACEMENT_OFFSET = 0;\nconst CONTENT_TO_LEFT = 'left';\nconst CONTENT_TO_RIGHT = 'right';\nconst MAX_MOBILE_SCREEN_WIDTH = 767;\n\nconst isControlledMenu = (isOpenProp, onToggleActiveProp) => {\n  return isOpenProp !== null && onToggleActiveProp !== null;\n};\n\nclass Menu extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = { isOpen: false, ready: false };\n\n    const { isOpen, onToggleActive } = props;\n    const isIndependentMenu = isOpen === null && onToggleActive === null;\n    if (!(isIndependentMenu || isControlledMenu(isOpen, onToggleActive))) {\n      throw new Error(\n        `Menu has invalid props:\n          Both isOpen and onToggleActive need to be defined (controlled menu),\n          or neither of them (menu uses its own state management).`\n      );\n    }\n\n    this.onBlur = this.onBlur.bind(this);\n    this.onKeyDown = this.onKeyDown.bind(this);\n    this.toggleOpen = this.toggleOpen.bind(this);\n    this.prepareChildren = this.prepareChildren.bind(this);\n    this.positionStyleForMenuContent = this.positionStyleForMenuContent.bind(this);\n    this.positionStyleForArrow = this.positionStyleForArrow.bind(this);\n\n    this.menu = null;\n    this.menuContent = null;\n  }\n  componentDidMount() {\n    // Menu needs to know about DOM before it can calculate it's size proberly.\n    this.setState({ ready: true });\n  }\n\n  onBlur(event) {\n    // FocusEvent is fired faster than the link elements native click handler\n    // gets its own event. Therefore, we need to check the origin of this FocusEvent.\n    if (!this.menu.contains(event.relatedTarget)) {\n      const { isOpen, onToggleActive } = this.props;\n\n      if (isControlledMenu(isOpen, onToggleActive)) {\n        onToggleActive(false);\n      } else {\n        this.setState({ isOpen: false });\n      }\n    }\n  }\n\n  onKeyDown(e) {\n    // Gather all escape presses to close menu\n    if (e.keyCode === KEY_CODE_ESCAPE) {\n      this.toggleOpen(false);\n    }\n  }\n\n  toggleOpen(enforcedState) {\n    // If state is handled outside of Menu component, we call a passed in onToggleActive func\n    const { isOpen, onToggleActive } = this.props;\n    if (isControlledMenu(isOpen, onToggleActive)) {\n      const isMenuOpen = enforcedState != null ? enforcedState : !isOpen;\n      onToggleActive(isMenuOpen);\n    } else {\n      // If state is handled inside of Menu component, set state\n      this.setState(prevState => {\n        const isMenuOpen = enforcedState != null ? enforcedState : !prevState.isOpen;\n        return { isOpen: isMenuOpen };\n      });\n    }\n  }\n\n  positionStyleForMenuContent(contentPosition) {\n    if (this.menu && this.menuContent) {\n      const windowWidth = window.innerWidth;\n      const rect = this.menu.getBoundingClientRect();\n\n      // Calculate wether we should show the menu to the left of the component or right\n      const distanceToRight = windowWidth - rect.right;\n      const menuWidth = this.menu.offsetWidth;\n      const contentWidthBiggerThanLabel = this.menuContent.offsetWidth - menuWidth;\n      const usePositionLeftFromLabel = contentPosition === CONTENT_TO_LEFT;\n      const contentPlacementOffset = this.props.contentPlacementOffset;\n\n      if (windowWidth <= MAX_MOBILE_SCREEN_WIDTH) {\n        // Take full screen width on mobile\n        return {\n          left: -1 * (rect.left - 24),\n          width: 'calc(100vw - 48px)',\n        };\n      }\n\n      // Render menu content to the left according to the contentPosition\n      // prop or if the content does not fit to the right. Otherwise render to\n      // the right.\n      return usePositionLeftFromLabel || distanceToRight < contentWidthBiggerThanLabel\n        ? { right: contentPlacementOffset, minWidth: menuWidth }\n        : { left: contentPlacementOffset, minWidth: menuWidth };\n    }\n\n    // When the MenuContent is rendered for the first time\n    // (for the sake of width calculation),\n    // move it outside of viewport to prevent possible overflow.\n    return this.state.isOpen ? {} : { left: '-10000px' };\n  }\n\n  positionStyleForArrow(isPositionedRight) {\n    if (this.menu) {\n      const menuWidth = this.menu.offsetWidth;\n      const contentPlacementOffset = this.props.contentPlacementOffset;\n      return isPositionedRight\n        ? Math.floor(menuWidth / 2) - contentPlacementOffset\n        : Math.floor(menuWidth / 2);\n    }\n    return 0;\n  }\n\n  prepareChildren() {\n    if (React.Children.count(this.props.children) !== 2) {\n      throw new Error('Menu needs to have two children: MenuLabel and MenuContent.');\n    }\n\n    return React.Children.map(this.props.children, child => {\n      const { isOpen: isOpenProp, onToggleActive } = this.props;\n      const isOpen = isControlledMenu(isOpenProp, onToggleActive) ? isOpenProp : this.state.isOpen;\n\n      if (child.type === MenuLabel) {\n        // MenuLabel needs toggleOpen function\n        // We pass that directly  so that component user doesn't need to worry about that\n        return React.cloneElement(child, {\n          isOpen,\n          onToggleActive: this.toggleOpen,\n        });\n      } else if (child.type === MenuContent) {\n        // MenuContent needs some styling data (width, arrowPosition, and isOpen info)\n        // We pass those directly so that component user doesn't need to worry about those.\n        const { contentPosition, useArrow } = this.props;\n        const positionStyles = this.positionStyleForMenuContent(contentPosition);\n        const arrowPosition = useArrow\n          ? this.positionStyleForArrow(positionStyles.right != null)\n          : null;\n        return React.cloneElement(child, {\n          arrowPosition,\n          contentRef: node => {\n            this.menuContent = node;\n          },\n          isOpen,\n          style: { ...child.props.style, ...positionStyles },\n        });\n      } else {\n        throw new Error('Menu has an unknown child. Only MenuLabel and MenuContent are allowed.');\n      }\n    });\n  }\n\n  render() {\n    const { className, rootClassName } = this.props;\n    const rootClass = rootClassName || css.root;\n    const classes = classNames(rootClass, className);\n    const menuChildren = this.state.ready ? this.prepareChildren() : null;\n\n    return (\n      <div\n        className={classes}\n        onBlur={this.onBlur}\n        tabIndex={0}\n        onKeyDown={this.onKeyDown}\n        ref={c => {\n          this.menu = c;\n        }}\n      >\n        {menuChildren}\n      </div>\n    );\n  }\n}\n\nMenu.defaultProps = {\n  className: null,\n  rootClassName: '',\n  contentPlacementOffset: CONTENT_PLACEMENT_OFFSET,\n  contentPosition: CONTENT_TO_RIGHT,\n  isOpen: null,\n  onToggleActive: null,\n  useArrow: true,\n};\n\nconst { bool, func, node, number, string } = PropTypes;\n\nMenu.propTypes = {\n  children: node.isRequired,\n  className: string,\n  rootClassName: string,\n  contentPosition: string,\n  contentPlacementOffset: number,\n  useArrow: bool,\n  isOpen: bool,\n  onToggleActive: func,\n};\n\nexport default Menu;\n"]},"metadata":{},"sourceType":"module"}